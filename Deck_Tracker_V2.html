<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Deck Match Tracker</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            color: #d8d8d8;
            background-color: #3a2e22;
         }
        .container {
            max-width: 750px;
            margin: 40px auto;
            background: rgba(30, 30, 30, 0.95);
             padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.8);
            border: 3px solid #a87e50;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
            background-color: #27883d;
            padding: 15px;
            border-radius: 8px;
        }
        h1, h2 {
            color: #fff;
            margin: 0;
            text-shadow: 1px 1px 3px #000;
        }
        h2 {
            font-size: 1.2em;
            margin-top: 10px;
        }
        h4 {
            color: #a87e50;
            text-align: center;
            margin-top: 20px;
            margin-bottom: 5px;
        }
        form, .stats-section, .deck-selector, .user-selector { /* Nova classe user-selector */
            background-color: #595959;
             padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #737373;
        }
        .user-selector { /* Estilo específico para o seletor de usuário */
            background-color: #3a2e22;
            border: 2px solid #fff;
        }
        .deck-selector {
            background-color: #27883d;
            border: 2px solid #ffd700;
        }
        .deck-selector label, .user-selector label {
            color: #fff;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        input[type="number"], input[type="text"], select, button {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border-radius: 6px;
            border: 1px solid #27883d;
            box-sizing: border-box;
            background-color: #f0f0f0;
            color: #3a2e22;
        }
        button {
            background-color: #27883d;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #329f4b;
        }
        /* ... (Resto dos estilos permanece o mesmo) ... */
        .stats-section {
            display: flex;
            justify-content: space-between;
            text-align: center;
        }
        .stats-section.general-stats {
            background-size: cover;
            background-position: center 20%;
            background-color: #3a2e22;
             position: relative;
            overflow: hidden;
            color: #fff;
             display: block;
         }
        .stats-section.general-stats::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
             z-index: 1;
        }
        .stats-section.general-stats h2,
        .stats-section.general-stats h4,
        .stats-section.general-stats .stats-item {
            position: relative;
            z-index: 2;
        }
        .stats-section.general-stats .stats-section {
             display: flex;
             background: none;
             padding: 0;
             margin-bottom: 0;
             border: none;
        }
        .stats-item {
            flex-grow: 1;
            margin: 0 5px;
            padding: 10px;
            border-radius: 6px;
            background-color: #3a2e22;
            border: 1px solid #a87e50;
        }
        .stats-label {
            font-size: 0.8em;
            color: #ccc;
        }
        .stats-value {
            font-size: 1.8em;
            font-weight: bolder;
            color: #a87e50;
            margin-top: 5px;
        }
        #status {
            text-align: center;
            padding: 10px;
            border-radius: 6px;
            margin-top: 20px;
            font-weight: bold;
            background-color: #3a2e22;
            border: 1px solid #737373;
        }
        .loading { color: #ffd700; }
        .error { color: #ff6347; }
        .success { color: #27883d; }
        #matchup-stats-display {
            display: none;
            margin-top: 15px;
            border-top: 1px dashed #a87e50;
            padding-top: 15px;
        }
        #matchup-stats-display .stats-item {
            background-color: #3a2e22;
            border-color: #27883d;
        }
        #nova-matchup-container, #novo-deck-container, #novo-usuario-container { /* Adicionado #novo-usuario-container */
            display: none;
        }
        .control-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .control-buttons button {
            flex: 1;
            margin-bottom: 0;
            padding: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Multi-Deck Match Tracker</h1>
            <h2>Rastreamento para Múltiplos Decks (Cloud)</h2>
        </header>
        
        <div class="user-selector">
            <label for="user-select">Selecione o Usuário:</label>
            <select id="user-select" required>
                <option value="" disabled selected>Selecione seu Nome</option>
                </select>
            <div id="novo-usuario-container">
                <label for="novo-usuario-input">Nome do Novo Usuário:</label>
                <input type="text" id="novo-usuario-input" placeholder="Ex: Gominho">
                <button type="button" onclick="setNovoUsuario()">Entrar</button>
            </div>
        </div>

        <div class="deck-selector">
            <label for="current-deck-select">Selecione seu Deck Atual:</label>
            <select id="current-deck-select" required disabled>
                <option value="" disabled selected>Selecione um Usuário Primeiro</option>
            </select>
            <div id="novo-deck-container">
                <label for="novo-deck-input">Nome do Novo Deck:</label>
                <input type="text" id="novo-deck-input" placeholder="Ex: Murktide Regent">
                <button type="button" onclick="criarNovoDeck()">Criar Deck</button>
            </div>
        </div>
        
        <div class="control-buttons">
            <button type="button" onclick="exportData()" disabled id="export-btn">Exportar Dados</button>
            <button type="button" onclick="document.getElementById('file-input').click()" disabled id="import-btn">Importar Dados</button>
            <input type="file" id="file-input" accept=".txt,.json" style="display: none;">
        </div>
        
        <form id="matchup-form">
            <label for="deck-oponente-select">Deck Oponente:</label>
            <select id="deck-oponente-select" required disabled>
                <option value="" disabled selected>Selecione o Deck Oponente</option>
            </select>
            <div id="nova-matchup-container">
                <label for="nova-matchup-input">Nova Matchup:</label>
                <input type="text" id="nova-matchup-input" placeholder="Ex: Boros Energy">
            </div>
                        <label for="g1-result">Resultado do Game 1:</label>
            <select id="g1-result" required disabled>
                <option value="" disabled selected>G1</option>
                <option value="win">Vitória</option>
                <option value="loss">Derrota</option>
            </select>
            <label for="g2-result">Resultado do Game 2:</label>
            <select id="g2-result" required disabled>
                <option value="" disabled selected>G2</option>
                <option value="win">Vitória</option>
                <option value="loss">Derrota</option>
            </select>
                        <label for="g3-result">Resultado do Game 3:</label>
            <select id="g3-result" disabled>
                <option value="not_played" selected>Não Jogou (2-0 ou 0-2)</option>
                <option value="win">Vitória</option>
                <option value="loss">Derrota</option>
            </select>
                        <button type="submit" disabled id="submit-match">Registrar Partida</button>
        </form>
        <div class="stats-section general-stats">
            <h2>Estatísticas Gerais - <span id="current-deck-name">Selecione um Deck</span></h2>
            <div class="stats-item">
                <div class="stats-value" id="wr-match-geral">--%</div>
                <div class="stats-label">Win Rate (Matches)</div>
            </div>
            <div class="stats-item">
                <div class="stats-value" id="wr-game-geral">--%</div>
                <div class="stats-label">Win Rate (Games)</div>
            </div>
                        <h4>Win Rate por Game (G1/G2/G3)</h4>
            <div class="stats-section">
                 <div class="stats-item">
                    <div class="stats-value" id="wr-g1-geral">--%</div>
                    <div class="stats-label">Game 1 WR</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="wr-g2-geral">--%</div>
                    <div class="stats-label">Game 2 WR</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="wr-g3-geral">--%</div>
                    <div class="stats-label">Game 3 WR</div>
                </div>
            </div>
        </div>
        <form id="matchup-stats-form">
            <h2>Estatísticas por Matchup</h2>
            <label for="matchup-select">Selecione um Matchup:</label>
            <select id="matchup-select" disabled>
                <option value="" selected>Selecione um Deck...</option>
            </select>
        </form>
                <div id="matchup-stats-display">
            <h3>Matchup contra: <span id="matchup-name"></span></h3>
                        <div class="stats-section">
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-match">--%</div>
                    <div class="stats-label">Match Win Rate</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-game">--%</div>
                    <div class="stats-label">Game Win Rate Total</div>
                </div>
            </div>
                        <h4>Win Rate por Game (G1/G2/G3)</h4>
            <div class="stats-section">
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-g1">--%</div>
                    <div class="stats-label">Game 1 WR</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-g2">--%</div>
                    <div class="stats-label">Game 2 WR</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-g3">--%</div>
                    <div class="stats-label">Game 3 WR</div>
                </div>
            </div>
        </div>
        <div id="status" class="loading">Inicie selecionando um usuário.</div>
    </div>
    
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

    <script>
        // CONFIGURAÇÃO FIREBASE EMBUTIDA
        const firebaseConfig = {
            apiKey: "AIzaSyDXVYDMwvnUoCUMTlvh8egzqS06_o497y8",
            authDomain: "mtg-tracker-ea7a2.firebaseapp.com",
            databaseURL: "https://mtg-tracker-ea7a2-default-rtdb.firebaseio.com",
            projectId: "mtg-tracker-ea7a2",
            storageBucket: "mtg-tracker-ea7a2.firebasestorage.app",
            messagingSenderId: "365839696243",
            appId: "1:365839696243:web:72d8c86b1d4acafbc7c506",
            measurementId: "G-029H8PTYRH"
        };

        // VARIÁVEIS MULTI-USUÁRIO
        let currentUser = null;
        const USERS = ['Chico', 'Capi', 'Maciel', 'Avelã', 'Gominho'];
        const NOVO_USUARIO_OPCAO = 'NOVO_USUARIO';
        
        const NOVO_DECK_OPCAO = 'NOVO_DECK';
        const NOVA_MATCHUP_OPCAO = 'NOVA_MATCHUP';

        const MODERN_METAGAME_DECKS = [
            'Esper Goryo\'s', 'Tameshi Belcher', 'Boros Energy', 'Eldrazi Tron',
            'Izzet Affinity', 'Esper Blink', 'Simic Neoform', 'Domain Zoo',
            'Azorius Control', 'Mono-Green Tron', 'Murktide Regent', 'Rhinos',
            'Living End', 'Yawgmoth', 'Amulet Titan'
        ];
        
        // VARIÁVEIS DE CONEXÃO E DADOS
        let firebaseApp = null;
        let dbRef = null; // Agora será ajustado para o path do usuário: /users/Nome/decks
        let allData = {}; // Dados do usuário atual

        let currentDeck = null;
        const userSelect = document.getElementById('user-select');
        const currentDeckSelect = document.getElementById('current-deck-select');
        const deckOponenteSelect = document.getElementById('deck-oponente-select');
        const matchupSelect = document.getElementById('matchup-select');
        const statusElement = document.getElementById('status');
        const form = document.getElementById('matchup-form');
        const novaMatchupContainer = document.getElementById('nova-matchup-container');
        const novaMatchupInput = document.getElementById('nova-matchup-input');
        const novoDeckContainer = document.getElementById('novo-deck-container');
        const novoDeckInput = document.getElementById('novo-deck-input');
        const novoUsuarioContainer = document.getElementById('novo-usuario-container');
        const novoUsuarioInput = document.getElementById('novo-usuario-input');
        const displayDiv = document.getElementById('matchup-stats-display');
        const fileInput = document.getElementById('file-input');
        
        // Elementos a serem desativados/ativados
        const controlsToToggle = [
            currentDeckSelect, deckOponenteSelect, matchupSelect,
            document.getElementById('g1-result'), document.getElementById('g2-result'),
            document.getElementById('g3-result'), document.getElementById('submit-match'),
            document.getElementById('export-btn'), document.getElementById('import-btn')
        ];


        // FUNÇÕES DE CONEXÃO FIREBASE
        function initializeFirebase(config) {
            try {
                if (!firebaseApp) {
                    firebaseApp = firebase.initializeApp(config);
                }
                
                statusElement.textContent = 'Conectado ao Firebase. Selecione um usuário.';
                statusElement.className = 'success';
            } catch (e) {
                console.error("Erro ao inicializar o Firebase:", e);
                statusElement.textContent = `Erro ao inicializar o Firebase: ${e.message}`;
                statusElement.className = 'error';
            }
        }
        
        function loadUserData(username) {
            if (!firebaseApp) return;

            // Define a referência do banco de dados para o usuário específico
            dbRef = firebaseApp.database().ref(`users/${username}/decks`);
            currentUser = username;
            
            // Ativa todos os controles após a seleção do usuário
            controlsToToggle.forEach(control => control.disabled = false);

            statusElement.textContent = `Carregando dados de ${username}...`;
            statusElement.className = 'loading';
            
            // Listener para carregar e atualizar os dados em tempo real
            dbRef.on('value', (snapshot) => {
                allData = snapshot.val() || { };
                
                // Tenta manter o deck selecionado, ou seleciona o primeiro
                if (currentDeck && !allData[currentDeck]) {
                    currentDeck = Object.keys(allData)[0] || null;
                } else if (!currentDeck) {
                    currentDeck = Object.keys(allData)[0] || null;
                }
                
                popularDeckSelector();
                popularDropdowns();
                updateStatsDisplay(null);
                
                statusElement.textContent = `Usuário: ${currentUser}. Dados atualizados (Cloud).`;
                statusElement.className = 'success';
            }, (error) => {
                console.error("Erro de conexão com o Firebase:", error);
                statusElement.textContent = `Erro ao carregar dados do usuário ${username}: ${error.message}`;
                statusElement.className = 'error';
            });
        }
        
        function popularUserSelector() {
            userSelect.innerHTML = '';
            userSelect.appendChild(new Option('Selecione seu Nome', '', true, true));

            USERS.forEach(name => {
                userSelect.appendChild(new Option(name, name));
            });
            userSelect.appendChild(new Option('--- Novo Usuário ---', NOVO_USUARIO_OPCAO));
            
            // Tenta pré-selecionar o último usuário usado (se houver)
            const lastUser = localStorage.getItem('lastUser');
            if (lastUser && USERS.includes(lastUser)) {
                userSelect.value = lastUser;
                loadUserData(lastUser);
            }
        }
        
        function setNovoUsuario() {
            const nomeUsuario = novoUsuarioInput.value.trim();
            if (!nomeUsuario || USERS.includes(nomeUsuario)) {
                statusElement.textContent = 'Nome de usuário inválido ou já existe.';
                statusElement.className = 'error';
                return;
            }
            
            USERS.push(nomeUsuario); // Adiciona na lista temporariamente
            popularUserSelector(); // Repopula o dropdown
            userSelect.value = nomeUsuario; // Seleciona o novo usuário
            novoUsuarioContainer.style.display = 'none';
            novoUsuarioInput.value = '';
            
            // Salva o usuário no localStorage para persistência e carrega os dados
            localStorage.setItem('lastUser', nomeUsuario);
            loadUserData(nomeUsuario);
        }

        // FUNÇÕES DE DADOS (AGORA DEPENDEM DE currentUser E dbRef)

        function loadData() {
            initializeFirebase(firebaseConfig);
        }

        function getCurrentMatches() {
            return currentDeck ? (allData[currentDeck] || {}) : {};
        }

        function popularDeckSelector() {
            currentDeckSelect.innerHTML = '';
            const deckNames = Object.keys(allData).sort();
                        
            deckNames.forEach(name => {
                currentDeckSelect.appendChild(new Option(name, name));
            });
            currentDeckSelect.appendChild(new Option('--- Criar Novo Deck ---', NOVO_DECK_OPCAO));
            
            if (currentDeck) {
                currentDeckSelect.value = currentDeck;
            }
            updateStatsDisplay(null);
        }

        function criarNovoDeck() {
            const nomeDeck = novoDeckInput.value.trim();
            if (!nomeDeck || !dbRef) {
                statusElement.textContent = 'Erro: Selecione um usuário ou verifique a conexão.';
                statusElement.className = 'error';
                return;
            }
            if (allData[nomeDeck]) {
                statusElement.textContent = 'Esse deck já existe!';
                statusElement.className = 'error';
                return;
            }
            
            dbRef.child(nomeDeck).set({})
                .then(() => {
                    currentDeck = nomeDeck;
                    novoDeckContainer.style.display = 'none';
                    novoDeckInput.value = '';
                    statusElement.textContent = `Deck "${nomeDeck}" criado com sucesso! Sincronizando...`;
                    statusElement.className = 'loading';
                })
                .catch(error => {
                    statusElement.textContent = `Erro ao criar deck: ${error.message}`;
                    statusElement.className = 'error';
                });
        }

        function addMatch(newMatch) {
            if (!currentDeck || !dbRef) {
                statusElement.textContent = 'Erro: Selecione um deck ou usuário.';
                statusElement.className = 'error';
                return;
            }
            
            dbRef.child(currentDeck).push(newMatch)
                .then(() => {
                    statusElement.textContent = 'Partida registrada com sucesso! Sincronizando...';
                    statusElement.className = 'loading';
                })
                .catch(error => {
                    statusElement.textContent = `Erro ao salvar partida: ${error.message}`;
                    statusElement.className = 'error';
                });
                
            popularDropdowns();
        }

        function exportData() {
            if (!currentUser) return;
            // Exporta apenas os dados do usuário atual
            const data = JSON.stringify(allData, null, 2);
            if (data === '{}' || Object.keys(allData).length === 0) {
                statusElement.textContent = 'Não há dados para exportar.';
                statusElement.className = 'error';
                return;
            }
            const filename = `${currentUser}_deck_tracker_data.txt`;
            const blob = new Blob([data], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
                        
            statusElement.textContent = `Dados de ${currentUser} exportados com sucesso!`;
            statusElement.className = 'success';
        }
        
        function importData(jsonString) {
            if (!dbRef || !currentUser) {
                statusElement.textContent = 'Erro: Selecione um usuário para importar dados.';
                statusElement.className = 'error';
                return;
            }
            try {
                // A importação agora espera um OBJETO de decks: {"Deck 1": [...matches], "Deck 2": [...matches]}
                const importedData = JSON.parse(jsonString);                                
                
                // Verifica se a importação é um objeto de decks
                if (typeof importedData !== 'object' || Array.isArray(importedData)) {
                    statusElement.textContent = 'Erro: O arquivo deve ser um objeto JSON (ex: {"Deck Name": [{...}, {...}]}).';
                    statusElement.className = 'error';
                    return;
                }

                // Define o nó de 'decks' do usuário atual com os dados importados
                dbRef.set(importedData)
                    .then(() => {
                        statusElement.textContent = `Dados importados para ${currentUser} e sincronizados com o Firebase!`;
                        statusElement.className = 'success';
                    })
                    .catch(e => {
                        statusElement.textContent = `Erro ao importar para o Firebase: ${e.message}`;
                        statusElement.className = 'error';
                    });
                
            } catch (e) {
                statusElement.textContent = `Erro ao analisar o arquivo de importação: ${e.message}`;
                statusElement.className = 'error';
            }
        }

        // --- (As funções handleFileSelect, calculateStats, updateStatsDisplay, popularDropdowns permanecem as mesmas) ---

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => importData(e.target.result);
            reader.onerror = () => {
                statusElement.textContent = 'Erro ao ler o arquivo';
                statusElement.className = 'error';
            };
            reader.readAsText(file);
            event.target.value = null;
        }

        function calculateStats(filteredData) {
            const matchesArray = Object.values(filteredData || {});
            
            let totalMatches = 0, matchesWon = 0, totalGames = 0, gamesWon = 0;
            let g1Total = 0, g1Won = 0, g2Total = 0, g2Won = 0, g3Total = 0, g3Won = 0;

            for (const match of matchesArray) {
                const g1 = match.g1Result ? match.g1Result.toLowerCase() : '';
                const g2 = match.g2Result ? match.g2Result.toLowerCase() : '';
                const g3 = match.g3Result ? match.g3Result.toLowerCase() : 'not_played';

                if (g1) { g1Total++; if (g1 === 'win') { g1Won++; gamesWon++; } }
                if (g2) { g2Total++; if (g2 === 'win') { g2Won++; gamesWon++; } }
                if (g3 !== 'not_played' && g3) { g3Total++; if (g3 === 'win') { g3Won++; gamesWon++; } }

                totalMatches++;
                let wins = (g1 === 'win' ? 1 : 0) + (g2 === 'win' ? 1 : 0) + (g3 === 'win' ? 1 : 0);
                if (wins >= 2) matchesWon++;
            }

            totalGames = g1Total + g2Total + g3Total;

            const formatWR = (num, den) => den > 0 ? (num / den * 100).toFixed(1) + '%' : '--%';
            
            return {
                generalWinRate: formatWR(matchesWon, totalMatches),
                gameWinRate: formatWR(gamesWon, totalGames),
                g1WinRate: formatWR(g1Won, g1Total),
                g2WinRate: formatWR(g2Won, g2Total),
                g3WinRate: formatWR(g3Won, g3Total)
            };
        }

        function updateStatsDisplay(matchupName = null) {
            const currentMatches = getCurrentMatches();
            let filteredMatches;

            if (matchupName) {
                filteredMatches = Object.values(currentMatches).filter(m => m.deckOponente === matchupName);
                document.getElementById('matchup-name').textContent = matchupName;
                displayDiv.style.display = 'block';
            } else {
                filteredMatches = currentMatches;
                displayDiv.style.display = 'none';
            }

            const stats = calculateStats(filteredMatches);

            if (matchupName) {
                document.getElementById('matchup-wr-match').textContent = stats.generalWinRate;
                document.getElementById('matchup-wr-game').textContent = stats.gameWinRate;
                document.getElementById('matchup-wr-g1').textContent = stats.g1WinRate;
                document.getElementById('matchup-wr-g2').textContent = stats.g2WinRate;
                document.getElementById('matchup-wr-g3').textContent = stats.g3WinRate;
            } else {
                document.getElementById('wr-match-geral').textContent = stats.generalWinRate;
                document.getElementById('wr-game-geral').textContent = stats.gameWinRate;
                document.getElementById('wr-g1-geral').textContent = stats.g1WinRate;
                document.getElementById('wr-g2-geral').textContent = stats.g2WinRate;
                document.getElementById('wr-g3-geral').textContent = stats.g3WinRate;

                const matchCount = Object.keys(currentMatches).length;
                document.getElementById('current-deck-name').textContent = currentDeck || 'Nenhum';
                
                if (currentDeck && matchCount > 0) {
                    statusElement.textContent = `Usuário: ${currentUser}. ${currentDeck}: ${matchCount} partidas registradas (Cloud).`;
                    statusElement.className = 'success';
                } else if (currentDeck && matchCount === 0) {
                    statusElement.textContent = `Usuário: ${currentUser}. Deck "${currentDeck}" pronto. Registre sua primeira partida!`;
                    statusElement.className = 'error';
                } else if (currentUser && Object.keys(allData).length === 0) {
                     statusElement.textContent = `Usuário: ${currentUser}. Crie seu primeiro deck!`;
                    statusElement.className = 'error';
                }
            }
        }

        function popularDropdowns() {
            const currentMatches = getCurrentMatches();
            
            const recordedDecks = new Set(Object.values(currentMatches).map(m => m.deckOponente));
                        
            let uniqueDecks = [...MODERN_METAGAME_DECKS];
            recordedDecks.forEach(deck => {
                if (!uniqueDecks.includes(deck)) uniqueDecks.push(deck);
            });
            uniqueDecks.sort();

            deckOponenteSelect.innerHTML = '';
            deckOponenteSelect.appendChild(new Option('Selecione o Deck Oponente', '', true, true));
            uniqueDecks.forEach(name => deckOponenteSelect.appendChild(new Option(name, name)));
            deckOponenteSelect.appendChild(new Option('--- Nova Matchup (Manual) ---', NOVA_MATCHUP_OPCAO));
            
            matchupSelect.innerHTML = '';
            matchupSelect.appendChild(new Option('Selecione um Deck...', ''));
            uniqueDecks.forEach(name => matchupSelect.appendChild(new Option(name, name)));
        }

        // Event Listeners
        
        // NOVO EVENTO: Seleção de Usuário
        userSelect.addEventListener('change', (e) => {
            const selectedUser = e.target.value;
            localStorage.setItem('lastUser', selectedUser); // Salva o último usuário
            
            if (selectedUser === NOVO_USUARIO_OPCAO) {
                novoUsuarioContainer.style.display = 'block';
                novoUsuarioInput.focus();
                // Desativa os controles
                controlsToToggle.forEach(control => control.disabled = true);
            } else {
                novoUsuarioContainer.style.display = 'none';
                loadUserData(selectedUser);
            }
        });
        
        currentDeckSelect.addEventListener('change', (e) => {
            if (e.target.value === NOVO_DECK_OPCAO) {
                novoDeckContainer.style.display = 'block';
                novoDeckInput.focus();
            } else {
                currentDeck = e.target.value;
                novoDeckContainer.style.display = 'none';
                popularDropdowns();
                updateStatsDisplay(null);
            }
        });

        form.addEventListener('submit', (e) => {
            e.preventDefault();
                        
            if (!currentDeck) {
                statusElement.textContent = 'Selecione um deck primeiro!';
                statusElement.className = 'error';
                return;
            }
            
            let deckOponente = deckOponenteSelect.value;
            
            if (deckOponente === NOVA_MATCHUP_OPCAO) {
                deckOponente = novaMatchupInput.value.trim();
                if (!deckOponente) {
                    statusElement.textContent = 'Digite o nome da nova matchup!';
                    statusElement.className = 'error';
                    return;
                }
            }
            
            const g1Result = document.getElementById('g1-result').value;
            const g2Result = document.getElementById('g2-result').value;
            const g3Result = document.getElementById('g3-result').value;
            
            if (!deckOponente || !g1Result || !g2Result) {
                statusElement.textContent = 'Preencha todos os campos obrigatórios!';
                statusElement.className = 'error';
                return;
            }

            const newMatch = {
                timestamp: new Date().toISOString(),
                deckProprio: currentDeck,
                deckOponente: deckOponente,
                g1Result: g1Result,
                g2Result: g2Result,
                g3Result: g3Result
            };
                        
            addMatch(newMatch);
            
            form.reset();
            document.getElementById('g3-result').value = 'not_played';
            novaMatchupContainer.style.display = 'none';
        });

        matchupSelect.addEventListener('change', (e) => {
            const selectedMatchup = e.target.value;
            if (selectedMatchup) {
                updateStatsDisplay(selectedMatchup);
            } else {
                displayDiv.style.display = 'none';
                updateStatsDisplay(null);
            }
        });

        deckOponenteSelect.addEventListener('change', (e) => {
            if (e.target.value === NOVA_MATCHUP_OPCAO) {
                novaMatchupContainer.style.display = 'block';
                novaMatchupInput.setAttribute('required', 'required');
                novaMatchupInput.focus();
            } else {
                novaMatchupContainer.style.display = 'none';
                novaMatchupInput.removeAttribute('required');
                novaMatchupInput.value = '';
            }
        });

        fileInput.addEventListener('change', handleFileSelect, false);

        // Initialization
        document.addEventListener('DOMContentLoaded', () => {
            loadData(); 
            popularUserSelector(); // Popula o dropdown de usuários primeiro
        });
    </script>
</body>
</html>
