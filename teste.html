<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Deck Match Tracker</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            color: #d8d8d8;
            background-color: #3a2e22;
         }
        .container {
            max-width: 750px;
            margin: 40px auto;
            background: rgba(30, 30, 30, 0.95);
             padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.8);
            border: 3px solid #a87e50;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
            background-color: #27883d;
            padding: 15px;
            border-radius: 8px;
        }
        h1, h2 {
            color: #fff;
            margin: 0;
            text-shadow: 1px 1px 3px #000;
        }
        h2 {
            font-size: 1.2em;
            margin-top: 10px;
        }
        h4 {
            color: #e0ac66;
            border-bottom: 2px solid #e0ac66;
            padding-bottom: 5px;
            margin-top: 25px;
        }
        form, .data-display, .import-export {
            background: #282828;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #444;
        }
        label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
            color: #ccc;
        }
        input[type="text"], select, button {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #555;
            border-radius: 4px;
            box-sizing: border-box;
            background-color: #3c3c3c;
            color: #fff;
        }
        button {
            background-color: #27883d;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #1a652d;
        }
        .results-container {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        .results-container select {
            flex-grow: 1;
        }
        .results-container .select-wrapper {
            flex-grow: 1;
        }
        #stats-display, #historic-display {
            padding: 15px;
            border: 1px solid #666;
            border-radius: 4px;
            margin-top: 15px;
            min-height: 50px;
            background-color: #333;
        }
        /* ESTILOS NOVOS PARA O DECK LIST */
        .deck-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #555;
            padding: 0 10px; /* Ajuste para melhor visualiza√ß√£o */
            margin-bottom: 15px;
            border-radius: 4px;
        }
        .deck-item {
            padding: 8px 10px;
            border-bottom: 1px solid #444;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .deck-item:last-child {
             border-bottom: none; /* Remove a linha do √∫ltimo item */
        }
        .deck-item:hover {
            background-color: #444;
        }
        .deck-item.selected {
            background-color: #a87e50; /* Cor de destaque */
            color: #fff;
            font-weight: bold;
            border-left: 5px solid #27883d;
        }
    </style>
    <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-database.js"></script>
    
</head>
<body>
    <div class="container">
        <header>
            <h1>Multi-Deck Match Tracker</h1>
            <h2>Para Magic: The Gathering</h2>
        </header>

        <div id="user-management">
            <h4>Sele√ß√£o de Usu√°rio</h4>
            <label for="user-select">Selecione o Usu√°rio:</label>
            <select id="user-select"></select>
            
            <form id="user-form" style="margin-top: 15px;">
                <label for="new-user-input">Novo Usu√°rio:</label>
                <input type="text" id="new-user-input" placeholder="Digite o nome do novo usu√°rio" required>
                <button type="submit">Criar Usu√°rio</button>
            </form>
        </div>

        <div id="deck-selection" style="margin-top: 20px;">
            <label for="formato-select">Formato:</label>
            <select id="formato-select">
                <option value="Modern">Modern</option>
                <option value="Pioneer">Pioneer</option>
                <option value="Legacy">Legacy</option>
                <option value="Standard">Standard</option>
                <option value="Pauper">Pauper</option>
            </select>

            <h4>Selecione Seu Deck Atual</h4>
            
            <div id="deck-list" class="deck-list">
                <p style="color:#aaa; padding: 10px 0;">Selecione um Usu√°rio e um Formato para carregar.</p>
            </div>
            
            <form id="new-deck-form">
                <label for="new-deck-input">Novo Deck Pr√≥prio:</label>
                <input type="text" id="new-deck-input" placeholder="Ex: Amulet Titan" required>
                <button type="submit">Adicionar Deck</button>
            </form>

            <select id="deck-select" style="display: none;">
                <option value="">-- Selecione o Deck Pr√≥prio --</option>
            </select>
            
            <label for="matchup-select">Filtrar Matchup (Opcional):</label>
            <select id="matchup-select">
                <option value="">-- Mostrar Todos os Matchups --</option>
            </select>
        </div>

        <div class="data-display" id="data-display" style="display: none;">
            <h4>Estat√≠sticas</h4>
            <div id="stats-display">Nenhum dado para exibir.</div>

            <form id="matchup-form">
                <h4>Registrar Nova Partida</h4>
                
                <label for="deck-oponente-select">Deck Oponente:</label>
                <select id="deck-oponente-select" required>
                    <option value="">-- Selecione o Deck Oponente --</option>
                </select>

                <div id="nova-matchup-container" style="display: none; margin-bottom: 15px;">
                    <label for="nova-matchup-input">Nome do Novo Deck Oponente:</label>
                    <input type="text" id="nova-matchup-input" placeholder="Ex: Grixis Delver">
                </div>

                <div class="results-container">
                    <div class="select-wrapper">
                        <label for="g1-result">Game 1:</label>
                        <select id="g1-result" name="g1-result" required>
                            <option value="win">Win (G1)</option>
                            <option value="loss">Loss (G1)</option>
                            <option value="draw">Draw (G1)</option>
                        </select>
                    </div>
                    <div class="select-wrapper">
                        <label for="g2-result">Game 2:</label>
                        <select id="g2-result" name="g2-result" required>
                            <option value="win">Win (G2)</option>
                            <option value="loss">Loss (G2)</option>
                            <option value="draw">Draw (G2)</option>
                        </select>
                    </div>
                    <div class="select-wrapper">
                        <label for="g3-result">Game 3:</label>
                        <select id="g3-result" name="g3-result">
                            <option value="not_played">N/J (G3)</option>
                            <option value="win">Win (G3)</option>
                            <option value="loss">Loss (G3)</option>
                            <option value="draw">Draw (G3)</option>
                        </select>
                    </div>
                </div>

                <button type="submit">Adicionar Matchup</button>
            </form>

            <div id="historic-display"></div>
        </div>
        
        <div class="import-export">
            <h4>Importar / Exportar Dados do Deck Selecionado</h4>
            <button onclick="document.getElementById('file-input').click()">Importar JSON do Deck</button>
            <input type="file" id="file-input" accept=".json" style="display: none;">
            <button id="export-button" onclick="exportData()">Exportar JSON do Deck</button>
        </div>

    </div>

    <script>
        // Configura√ß√£o do Firebase
        // ATEN√á√ÉO: Substitua os dados abaixo pelos da sua aplica√ß√£o Firebase!
        const firebaseConfig = {
            apiKey: "AIzaSyDXVYDMwvnUoCUMTlvh8egzqS06_o497y8",
            authDomain: "mtg-tracker-ea7a2.firebaseapp.com",
            databaseURL: "https://mtg-tracker-ea7a2-default-rtdb.firebaseio.com",
            projectId: "mtg-tracker-ea7a2",
            storageBucket: "mtg-tracker-ea7a2.firebasestorage.app",
            messagingSenderId: "365839696243",
            appId: "1:365839696243:web:72d8c86b1d4acafbc7c506",
            measurementId: "G-029H8PTYRH"
        };
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // Vari√°veis globais
        // ESTRUTURA: {usuario: {formato: {deck: [{match}, {match}, ...]}}}
        let allMatches = {}; 
        let selectedUser = null;
        let currentFormat = 'Modern'; 
        const NOVA_MATCHUP_OPCAO = 'Novo Deck';

        // Elementos do DOM
        const userSelector = document.getElementById('user-select');
        const userManagementDiv = document.getElementById('user-management');
        const newUserInput = document.getElementById('new-user-input');
        
        // Novos elementos para o novo layout de sele√ß√£o de deck
        const deckListContainer = document.getElementById('deck-list');
        const newDeckForm = document.getElementById('new-deck-form');
        const newDeckInput = document.getElementById('new-deck-input');

        // SELECT escondido (mantido para compatibilidade de valor)
        const deckSelector = document.getElementById('deck-select'); 

        const deckOponenteSelect = document.getElementById('deck-oponente-select');
        const matchupSelect = document.getElementById('matchup-select');
        const novaMatchupContainer = document.getElementById('nova-matchup-container');
        const novaMatchupInput = document.getElementById('nova-matchup-input');
        const statsDiv = document.getElementById('stats-display');
        const historicDiv = document.getElementById('historic-display');
        const displayDiv = document.getElementById('data-display');
        const fileInput = document.getElementById('file-input');
        const formatoSelect = document.getElementById('formato-select');

        // Metagames por Formato (LISTAS DE DECK)
        const METAGAME_DECKS_BY_FORMAT = {
            'Modern': [
                'Esper Goryo\'s', 'Tameshi Belcher', 'Boros Energy', 'Eldrazi Tron',
                'Izzet Affinity', 'Esper Blink', 'Simic Neoform', 'Domain Zoo',
                'Azorius Control', 'Mono-Green Tron', 'Murktide Regent', 'Rhinos',
                'Living End', 'Yawgmoth', 'Amulet Titan', 'Outro' // 'Outro' para decks fora da lista
            ],
            'Pioneer': [
                'Rakdos Midrange', 'Izzet Phoenix', 'Azorius Control', 'Lotus Field Combo',
                'Gruul Prowess', 'Boros Convoke', 'Abzan Greasefang', 'Mono Black Midrange',
                'Selesnya Angels', 'Niv to Light', 'Outro'
            ],
            'Legacy': [
                'Izzet Delver', 'Dimir Reanimator', 'Eldrazi', 'Red Stompy',
                'Dimir Tempo', 'Azorius Control', 'Jeskai Control',
                '4c Initiative', 'The EPIC Storm', 'Outro'
            ],
            'Standard': [
                'Izzet Cauldron', 'Dimir Midrange', 'Mono Red Aggro', 'Boros Burn',
                'Azorius Control', 'Mono Black', 'Gruul Landfall', 'Jeskai Artifacts',
                'Esper Control', 'Outro'
            ],
            'Pauper': [
                'Mono-Blue Terror', 'Madness Burn', 'Grixis Affinity',
                'Mono-Black Sacrifice', 'Golgari Gardens', 'Jeskai Ephemerate',
                'Spy Combo', 'Burn', 'Elves', 'Outro'
            ]
        };

        // --- FUN√á√ïES DE L√ìGICA ---

        function saveData() {
            if (selectedUser) {
                // Salva todos os dados do usu√°rio, incluindo todos os formatos
                database.ref('users/' + selectedUser).set(allMatches[selectedUser])
                    .catch(error => console.error("Erro ao salvar dados:", error));
            }
        }

        function loadData() {
            database.ref('users/').once('value')
                .then(snapshot => {
                    allMatches = snapshot.val() || {};
                    popularUserSelector();
                })
                .catch(error => console.error("Erro ao carregar dados:", error));
        }

        function popularUserSelector() {
            const users = Object.keys(allMatches);
            userSelector.innerHTML = '<option value="">-- Selecione o Usu√°rio --</option>';
            users.forEach(user => {
                const option = document.createElement('option');
                option.value = user;
                option.textContent = user;
                userSelector.appendChild(option);
            });
            userSelector.innerHTML += '<option value="Novo Usu√°rio">Novo Usu√°rio</option>';
            userManagementDiv.style.display = 'block';
        }

        function selectDeckFromList(e) {
            const newDeck = e.target.dataset.deckName;
            const currentSelectedDeck = deckSelector.value;
            
            if (newDeck === currentSelectedDeck) return; // N√£o faz nada se for o mesmo deck
            
            // Atualiza o select escondido (o valor que o resto do JS usa)
            deckSelector.value = newDeck; 

            // Remove a sele√ß√£o de todos os itens e adiciona ao item clicado
            document.querySelectorAll('.deck-item').forEach(div => div.classList.remove('selected'));
            e.target.classList.add('selected');
            
            // Re-popula os dropdowns (oponente/matchup) e atualiza estat√≠sticas
            popularDropdowns(); 
            updateStatsDisplay(null);
        }

        function popularDropdowns() {
            const selectedDeck = deckSelector.value; // Pega o deck atualmente selecionado
            // matchData: {formato: {deck: [...]}}
            const matchData = allMatches[selectedUser]; 
            // formatData: {deck: [...]}
            const formatData = matchData ? matchData[currentFormat] : null;

            // Se n√£o houver dados ou usu√°rio/formato selecionado
            if (!selectedUser || !formatData) {
                deckListContainer.innerHTML = '<p style="color:#aaa; padding: 10px 0;">Selecione um Usu√°rio e um Formato para carregar.</p>';
                deckSelector.innerHTML = '<option value="">-- Selecione o Deck Pr√≥prio --</option>';
                deckOponenteSelect.innerHTML = '<option value="">-- Selecione o Deck Oponente --</option>';
                matchupSelect.innerHTML = '<option value="">-- Selecione o Matchup --</option>';
                displayDiv.style.display = 'none';
                return;
            }

            // 1. Popula o Seletor de Deck Pr√≥prio (Lista Visual e Select Escondido)
            const decks = Object.keys(formatData); // Pega decks dentro do formato
            
            // Limpa o select escondido
            deckSelector.innerHTML = '<option value="">-- Selecione o Deck Pr√≥prio --</option>';
            
            // Limpa e popula o container visual
            deckListContainer.innerHTML = '';
            if (decks.length === 0) {
                deckListContainer.innerHTML = '<p style="color:#aaa; padding: 10px 0;">Nenhum deck encontrado neste formato. Adicione um abaixo.</p>';
            }

            decks.forEach(deck => {
                // Popula o SELECT escondido
                const option = document.createElement('option');
                option.value = deck;
                option.textContent = deck;
                deckSelector.appendChild(option);

                // Popula o Container Visual (deckListContainer)
                const deckDiv = document.createElement('div');
                deckDiv.textContent = deck;
                deckDiv.dataset.deckName = deck;
                deckDiv.classList.add('deck-item'); 
                
                if (deck === selectedDeck) {
                    deckDiv.classList.add('selected');
                }
                
                deckDiv.addEventListener('click', selectDeckFromList);
                deckListContainer.appendChild(deckDiv);
            });
            
            // Re-seleciona o valor no select escondido
            deckSelector.value = selectedDeck;


            // 2. Popula o Seletor de Deck Oponente
            deckOponenteSelect.innerHTML = '<option value="">-- Selecione o Deck Oponente --</option>';
            const metagameDecks = METAGAME_DECKS_BY_FORMAT[currentFormat] || ['Outro'];

            metagameDecks.forEach(deck => {
                if (deck !== selectedDeck) {
                    const option = document.createElement('option');
                    option.value = deck;
                    option.textContent = deck;
                    deckOponenteSelect.appendChild(option);
                }
            });
            deckOponenteSelect.innerHTML += `<option value="${NOVA_MATCHUP_OPCAO}">-- ${NOVA_MATCHUP_OPCAO} --</option>`;

            // 3. Popula o Seletor de Matchup
            const matchups = [...new Set(formatData[selectedDeck] ? formatData[selectedDeck].map(m => m.deckOponente) : [])];

            matchupSelect.innerHTML = '<option value="">-- Mostrar Todos os Matchups --</option>';
            matchups.sort().forEach(matchup => {
                const option = document.createElement('option');
                option.value = matchup;
                option.textContent = matchup;
                matchupSelect.appendChild(option);
            });

            // Mostra/Esconde a se√ß√£o de dados
            displayDiv.style.display = selectedDeck ? 'block' : 'none';
            updateStatsDisplay(null);
        }

        // Fun√ß√µes updateStatsDisplay, addMatch, deleteMatch, handleFileSelect, exportData
        // (Mant√™m a l√≥gica do c√≥digo anterior, agora usando deckSelector.value para o deck)
        // ... (resto das fun√ß√µes de l√≥gica mantidas)

        function updateStatsDisplay(matchup) {
            const selectedDeck = deckSelector.value;
            const formatData = allMatches[selectedUser] ? allMatches[selectedUser][currentFormat] : null;

            // Navega para a nova estrutura: allMatches[selectedUser][currentFormat][selectedDeck]
            if (!selectedUser || !selectedDeck || !formatData || !formatData[selectedDeck]) {
                statsDiv.innerHTML = '<p>Nenhum dado para exibir.</p>';
                historicDiv.innerHTML = '';
                return;
            }

            let matches = formatData[selectedDeck];
            if (matchup) {
                matches = matches.filter(m => m.deckOponente === matchup);
                historicDiv.innerHTML = `<h4>Hist√≥rico contra ${matchup}</h4>`;
            } else {
                historicDiv.innerHTML = `<h4>Hist√≥rico Completo</h4>`;
            }

            // Calcular Estat√≠sticas
            let wins = 0;
            let losses = 0;
            let draws = 0;
            let gamesPlayed = 0;

            matches.forEach(match => {
                const g1 = match.g1Result;
                const g2 = match.g2Result;
                const g3 = match.g3Result;
                
                // L√≥gica de c√°lculo de partida (best-of-three)
                let matchWins = 0;
                let matchLosses = 0;

                if (g1 === 'win') matchWins++;
                if (g2 === 'win') matchWins++;
                if (g3 === 'win') matchWins++;

                if (g1 === 'loss') matchLosses++;
                if (g2 === 'loss') matchLosses++;
                if (g3 === 'loss') matchLosses++;
                
                // Resultado final da partida
                if (matchWins > matchLosses) {
                    wins++;
                } else if (matchLosses > matchWins) {
                    losses++;
                } else if (matchWins === matchLosses && matchWins > 0) { // 1-1, 0-0 ou 2-2 (s√≥ 1-1 √© v√°lido)
                    draws++;
                }
                
                // Contagem total de partidas
                gamesPlayed++;
            });

            const winRate = gamesPlayed > 0 ? ((wins / gamesPlayed) * 100).toFixed(1) : 0;

            statsDiv.innerHTML = `
                <p><strong>Formato:</strong> ${currentFormat}</p>
                <p><strong>Deck Pr√≥prio:</strong> ${selectedDeck}</p>
                <p><strong>Total de Partidas:</strong> ${gamesPlayed}</p>
                <p><strong>Vit√≥rias (W):</strong> ${wins}</p>
                <p><strong>Derrotas (L):</strong> ${losses}</p>
                <p><strong>Empates (D):</strong> ${draws}</p>
                <p><strong>Win Rate (%):</strong> ${winRate}%</p>
            `;

            // Exibir Hist√≥rico
            historicDiv.innerHTML = historicDiv.innerHTML.replace('</h4>', ' (√öltimas 10)</h4>'); // Ajusta o t√≠tulo
            matches.reverse().slice(0, 10).forEach(match => {
                const date = new Date(match.timestamp).toLocaleString('pt-BR');
                const g1Class = match.g1Result;
                const g2Class = match.g2Result;
                const g3Class = match.g3Result;

                historicDiv.innerHTML += `
                    <div class="matchup-list">
                        <span>${date}</span>
                        <span>vs ${match.deckOponente}</span>
                        <span>
                            G1: <span class="${g1Class}">${g1Class === 'not_played' ? 'N/J' : g1Class.toUpperCase()}</span>
                            G2: <span class="${g2Class}">${g2Class === 'not_played' ? 'N/J' : g2Class.toUpperCase()}</span>
                            G3: <span class="${g3Class}">${g3Class === 'not_played' ? 'N/J' : g3Class.toUpperCase()}</span>
                        </span>
                        <span class="matchup-delete" data-timestamp="${match.timestamp}" title="Deletar Match">üóëÔ∏è</span>
                    </div>
                `;
            });

            // Adicionar listener de delete ao hist√≥rico
            historicDiv.querySelectorAll('.matchup-delete').forEach(button => {
                button.addEventListener('click', deleteMatch);
            });
        }

        function addMatch(newMatch) {
            if (!allMatches[selectedUser]) {
                allMatches[selectedUser] = {};
            }
            // Inicializa a chave do formato se n√£o existir
            if (!allMatches[selectedUser][currentFormat]) { 
                allMatches[selectedUser][currentFormat] = {};
            }

            const deckKey = newMatch.deckProprio;
            const matchupKey = newMatch.deckOponente;

            // Navega para a nova estrutura: allMatches[selectedUser][currentFormat][deckKey]
            if (!allMatches[selectedUser][currentFormat][deckKey]) {
                allMatches[selectedUser][currentFormat][deckKey] = [];
            }

            allMatches[selectedUser][currentFormat][deckKey].push(newMatch);
            saveData();
            
            // Atualiza os dropdowns para incluir o novo deck/matchup
            popularDropdowns(); 
            
            // Atualiza as estat√≠sticas
            updateStatsDisplay(matchupKey);
        }

        function deleteMatch(e) {
            const timestamp = e.target.getAttribute('data-timestamp');
            const deckKey = deckSelector.value;
            const formatData = allMatches[selectedUser][currentFormat]; // Obt√©m o objeto do formato
            
            if (confirm("Tem certeza que deseja deletar esta partida?")) {
                let matches = formatData[deckKey];
                const initialLength = matches.length;
                
                // Filtra e remove a partida com o timestamp correspondente (alterando a estrutura aninhada)
                allMatches[selectedUser][currentFormat][deckKey] = matches.filter(match => match.timestamp !== timestamp);

                if (allMatches[selectedUser][currentFormat][deckKey].length === initialLength) {
                     alert("Erro: Partida n√£o encontrada para dele√ß√£o.");
                     return;
                }

                saveData();
                updateStatsDisplay(matchupSelect.value); // Re-exibe as estat√≠sticas
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (selectedUser) {
                        const deckName = Object.keys(importedData)[0];
                        
                        if (Array.isArray(importedData[deckName])) {
                            
                            if (!allMatches[selectedUser]) {
                                allMatches[selectedUser] = {};
                            }
                            // Inicializa o formato atual se n√£o existir
                            if (!allMatches[selectedUser][currentFormat]) { 
                                allMatches[selectedUser][currentFormat] = {};
                            }

                            // Adiciona/Substitui o deck no objeto do usu√°rio sob o FORMATO ATUAL
                            allMatches[selectedUser][currentFormat][deckName] = importedData[deckName];
                            
                            saveData();
                            alert(`Dados do deck "${deckName}" importados com sucesso para o usu√°rio ${selectedUser} no formato ${currentFormat}!`);
                            
                            // Seleciona o deck importado
                            deckSelector.value = deckName;
                            
                            popularDropdowns();
                            updateStatsDisplay(null);
                        } else {
                            alert("Estrutura do arquivo JSON inv√°lida. Deve ser no formato {\"Nome do Deck\": [...]}.");
                        }
                    } else {
                        alert("Por favor, selecione um usu√°rio antes de importar os dados.");
                    }
                } catch (error) {
                    alert("Erro ao ler ou processar o arquivo JSON. Certifique-se de que o formato est√° correto.");
                    console.error("Erro na importa√ß√£o:", error);
                }
            };
            reader.readAsText(file);
        }

        function exportData() {
            const selectedDeck = deckSelector.value;
            if (!selectedDeck || !selectedUser) {
                alert("Selecione um usu√°rio e um deck para exportar.");
                return;
            }
            
            // L√™ do formato atual
            const deckData = allMatches[selectedUser][currentFormat] ? allMatches[selectedUser][currentFormat][selectedDeck] : null;

            if (!deckData || deckData.length === 0) {
                alert(`O deck "${selectedDeck}" n√£o possui dados para exportar.`);
                return;
            }

            const dataToExport = {};
            dataToExport[selectedDeck] = deckData;

            const jsonString = JSON.stringify(dataToExport, null, 4);
            const blob = new Blob([jsonString], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            // Nome do arquivo agora inclui o formato
            a.download = `${selectedUser}_${currentFormat}_${selectedDeck}_tracker_data.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }


        // --- EVENT LISTENERS E INICIALIZA√á√ÉO ---

        document.getElementById('user-form').addEventListener('submit', (e) => {
            e.preventDefault();
            selectedUser = newUserInput.value.trim();
            if (selectedUser && !allMatches[selectedUser]) {
                allMatches[selectedUser] = {};
                popularUserSelector();
                userSelector.value = selectedUser;
                userManagementDiv.style.display = 'none';
                popularDropdowns();
            } else if (selectedUser) {
                alert(`Usu√°rio ${selectedUser} j√° existe. Por favor, selecione-o na lista.`);
            }
        });

        // NOVO LISTENER: Adicionar Deck
        newDeckForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const newDeckName = newDeckInput.value.trim();
            
            if (deckSelector.value === newDeckName) {
                alert("Este deck j√° est√° selecionado.");
                return;
            }

            if (newDeckName && selectedUser && currentFormat) {
                // Cria um novo n√≥ de deck vazio
                if (!allMatches[selectedUser]) allMatches[selectedUser] = {};
                if (!allMatches[selectedUser][currentFormat]) allMatches[selectedUser][currentFormat] = {};

                if (allMatches[selectedUser][currentFormat][newDeckName]) {
                    alert(`O deck "${newDeckName}" j√° existe neste formato.`);
                    return;
                }

                allMatches[selectedUser][currentFormat][newDeckName] = [];
                saveData();
                
                // Atualiza o select escondido e a lista visual
                deckSelector.value = newDeckName; 
                
                popularDropdowns(); // Re-popula a lista (e o select escondido)
                updateStatsDisplay(null);
                newDeckInput.value = ''; // Limpa o campo
            } else {
                alert('Selecione um usu√°rio e um formato e forne√ßa um nome para o novo deck.');
            }
        });

        userSelector.addEventListener('change', (e) => {
            selectedUser = e.target.value;
            if (selectedUser === 'Novo Usu√°rio') {
                userManagementDiv.style.display = 'block';
                newUserInput.focus();
                selectedUser = null; 
                deckSelector.value = ''; // Limpa a sele√ß√£o de deck
                popularDropdowns();
            } else if (selectedUser) {
                userManagementDiv.style.display = 'none';
                deckSelector.value = ''; // Limpa a sele√ß√£o de deck
                popularDropdowns();
            } else {
                userManagementDiv.style.display = 'none';
                deckSelector.value = ''; // Limpa a sele√ß√£o de deck
                popularDropdowns();
            }
        });

        // Listener para o Seletor de Formato
        formatoSelect.addEventListener('change', (e) => {
            currentFormat = e.target.value;
            deckSelector.value = ''; // Limpa a sele√ß√£o de deck ao trocar o formato
            // Re-popula os dropdowns com os decks do novo formato
            popularDropdowns();
            updateStatsDisplay(matchupSelect.value); 
        });

        // O evento change no deckSelector agora √© desnecess√°rio, pois a fun√ß√£o popularDropdowns
        // j√° √© chamada pelos listeners de click na lista e format/user change.

        document.getElementById('matchup-form').addEventListener('submit', (e) => {
            e.preventDefault();
            
            const form = e.target;
            const deckProprio = deckSelector.value;
            let deckOponente = deckOponenteSelect.value;
            
            // Se o deckOponente for 'Novo Deck', pega o valor do campo de input
            if (deckOponente === NOVA_MATCHUP_OPCAO) {
                deckOponente = novaMatchupInput.value.trim();
            }

            if (!deckProprio || !deckOponente || !selectedUser) {
                alert('Por favor, preencha todos os campos e selecione um deck pr√≥prio.');
                return;
            }

            const g1Result = form.elements['g1-result'].value;
            const g2Result = form.elements['g2-result'].value;
            const g3Result = form.elements['g3-result'].value;
            
            const newMatch = {
                timestamp: new Date().toISOString(),
                deckProprio: deckProprio,
                deckOponente: deckOponente,
                g1Result: g1Result,
                g2Result: g2Result,
                g3Result: g3Result
            };
                        
            addMatch(newMatch);
            
            form.reset();
            document.getElementById('g3-result').value = 'not_played';
            novaMatchupContainer.style.display = 'none';
        });

        matchupSelect.addEventListener('change', (e) => {
            const selectedMatchup = e.target.value;
            if (selectedMatchup) {
                updateStatsDisplay(selectedMatchup);
            } else {
                updateStatsDisplay(null);
            }
        });

        deckOponenteSelect.addEventListener('change', (e) => {
            if (e.target.value === NOVA_MATCHUP_OPCAO) {
                novaMatchupContainer.style.display = 'block';
                novaMatchupInput.setAttribute('required', 'required');
                novaMatchupInput.focus();
            } else {
                novaMatchupContainer.style.display = 'none';
                novaMatchupInput.removeAttribute('required');
                novaMatchupInput.value = '';
            }
        });

        fileInput.addEventListener('change', handleFileSelect, false);

        // Initialization
        document.addEventListener('DOMContentLoaded', () => {
            loadData(); 
            popularUserSelector(); 

            // Inicializa o seletor de formato com o valor de currentFormat
            formatoSelect.value = currentFormat;
            popularDropdowns(); // Chama para popular os decks do formato padr√£o
        });
    </script>
</body>
</html>
