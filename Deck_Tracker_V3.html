<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Deck Match Tracker</title>
    <style>
    body {
        font-family: 'Arial', sans-serif;
        margin: 0;
        color: #d8d8d8;
        background-color: #3a2e22;
     }
    .container {
        max-width: 750px;
        margin: 40px auto;
        background: rgba(30, 30, 30, 0.95);
         padding: 30px;
        border-radius: 12px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.8);
        border: 3px solid #a87e50;
    }
    header {
        text-align: center;
        margin-bottom: 30px;
        /* Alterações de Fundo para tireless_tracker.jpg */
        background-image: url('./img/tireless_tracker.jpg'); /* Nome do arquivo: tireless_tracker.jpg */
        background-size: cover; /* Garante que a imagem cubra a área */
        background-position: center 20%; /* Centraliza a imagem no eixo X e move 20% para baixo */
        background-color: #27883d; /* Cor de fallback */
        padding: 15px;
        border-radius: 8px;
        position: relative; /* Necessário para z-index do pseudo-elemento */
        overflow: hidden; /* Oculta partes da imagem que possam extrapolar */
    }
    /* Overlay para o Header */
    header::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.4); /* Escurece a imagem para destacar o texto */
        z-index: 1;
    }
    /* Z-index para o conteúdo do Header */
    header h1, header h2 {
        position: relative;
        z-index: 2;
    }
    h1, h2 {
        color: #fff;
        margin: 0;
        text-shadow: 1px 1px 3px #000;
    }
    h2 {
        font-size: 1.2em;
        margin-top: 10px;
    }
    h4 {
        color: #a87e50;
        text-align: center;
        margin-top: 20px;
        margin-bottom: 5px;
    }
    form, .stats-section, .deck-selector, .user-selector, .format-selector { /* Adicionado .format-selector */
        background-color: #595959;
         padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
        border: 1px solid #737373;
    }
    .user-selector { /* Estilo específico para o seletor de usuário */
        background-color: #3a2e22;
        border: 2px solid #fff;
    }
    .deck-selector {
        background-color: #27883d;
        border: 2px solid #ffd700;
    }
    .deck-selector label, .user-selector label, .format-selector label {
        color: #fff;
    }
    label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
    }
    input[type="number"], input[type="text"], select, button {
        width: 100%;
        padding: 12px;
        margin-bottom: 15px;
        border-radius: 6px;
        border: 1px solid #27883d;
        box-sizing: border-box;
        background-color: #f0f0f0;
        color: #3a2e22;
    }
    button {
        background-color: #27883d;
        color: white;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.3s;
    }
    button:hover {
        background-color: #329f4b;
    }
    /* ... (Resto dos estilos permanece o mesmo) ... */
    .stats-section {
        display: flex;
        justify-content: space-between;
        text-align: center;
    }
    /* INÍCIO DA MODIFICAÇÃO PARA CORRIGIR A IMAGEM DE FUNDO */
    .stats-section.general-stats {
        /* Alterações de Fundo para laboratory_manic.jpg */
        background-image: url('./img/laboratory_manic.jpg'); /* Nome do arquivo: laboratory_manic.jpg */
        background-size: cover; /* Garante que a imagem cubra a área */
        background-position: center; /* Centraliza a imagem no container */
        background-color: #3a2e22;
         position: relative;
        overflow: hidden;
        color: #fff;
         /* display: block; <--- REMOVIDO: Mantém o padrão flex ou block, mas não sobrescreve de forma que possa atrapalhar o posicionamento dos filhos */
     }
    .stats-section.general-stats::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
         z-index: 1;
    }
    .stats-section.general-stats h2,
    .stats-section.general-stats h4,
    .stats-section.general-stats .stats-item {
        position: relative;
        z-index: 2; /* Garante que o conteúdo fique visível acima do overlay */
    }
    /* FIM DA MODIFICAÇÃO PARA CORRIGIR A IMAGEM DE FUNDO */

    .stats-section.general-stats .stats-section {
         display: flex;
         background: none;
         padding: 0;
         margin-bottom: 0;
         border: none;
    }
    .stats-item {
        flex-grow: 1;
        margin: 0 5px;
        padding: 10px;
        border-radius: 6px;
        background-color: #3a2e22;
        border: 1px solid #a87e50;
    }
    .stats-label {
        font-size: 0.8em;
        color: #ccc;
    }
    .stats-value {
        font-size: 1.8em;
        font-weight: bolder;
        color: #a87e50;
        margin-top: 5px;
    }
    #status {
        text-align: center;
        padding: 10px;
        border-radius: 6px;
        margin-top: 20px;
        font-weight: bold;
        background-color: #3a2e22;
        border: 1px solid #737373;
    }
    .loading { color: #ffd700; }
    .error { color: #ff6347; }
    .success { color: #27883d; }
    #matchup-stats-display {
        display: none;
        margin-top: 15px;
        border-top: 1px dashed #a87e50;
        padding-top: 15px;
    }
    #matchup-stats-display .stats-item {
        background-color: #3a2e22;
        border-color: #27883d;
    }
    #nova-matchup-container, #novo-deck-container, #novo-usuario-container { /* Adicionado #novo-usuario-container */
        display: none;
    }
    .control-buttons {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
    }
    .control-buttons button {
        flex: 1;
        margin-bottom: 0;
        padding: 10px;
    }
</style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Multi-Deck Match Tracker</h1>
            <h2>Rastreamento para Múltiplos Decks (Cloud)</h2>
        </header>
        
        <div class="user-selector">
            <label for="user-select">Selecione o Usuário:</label>
            <select id="user-select" required>
                <option value="" disabled selected>Selecione seu Nome</option>
                </select>
            <div id="novo-usuario-container">
                <label for="novo-usuario-input">Nome do Novo Usuário:</label>
                <input type="text" id="novo-usuario-input" placeholder="Ex: Gominho">
                <button type="button" onclick="setNovoUsuario()">Entrar</button>
            </div>
        </div>
        <div class="format-selector">
            <label for="current-format-select">Selecione o formato:</label>
            <select id="current-format-select" required disabled>
                <option value="" disabled selected>Selecione o Formato</option>
            </select>
        </div>
        <div class="deck-selector">
            <label for="current-deck-select">Selecione seu Deck Atual:</label>
            <select id="current-deck-select" required disabled>
                <option value="" disabled selected>Selecione um Usuário e Formato Primeiro</option>
            </select>
            <div id="novo-deck-container">
                <label for="novo-deck-input">Nome do Novo Deck:</label>
                <input type="text" id="novo-deck-input" placeholder="Ex: Boros Energy">
                <button type="button" onclick="criarNovoDeck()">Criar Deck</button>
            </div>
        </div>
        
        <div class="control-buttons">
            <button type="button" onclick="exportData()" disabled id="export-btn">Exportar Dados</button>
            <button type="button" onclick="document.getElementById('file-input').click()" disabled id="import-btn">Importar Dados</button>
            <input type="file" id="file-input" accept=".txt,.json" style="display: none;">
        </div>
        
        <form id="matchup-form">
            <label for="deck-oponente-select">Deck Oponente:</label>
            <select id="deck-oponente-select" required disabled>
                <option value="" disabled selected>Selecione o Deck Oponente</option>
            </select>
            <div id="nova-matchup-container">
                <label for="nova-matchup-input">Nova Matchup:</label>
                <input type="text" id="nova-matchup-input" placeholder="Ex: Boros Energy">
            </div>
                        <label for="g1-result">Resultado do Game 1:</label>
            <select id="g1-result" required disabled>
                <option value="" disabled selected>G1</option>
                <option value="win">Vitória</option>
                <option value="loss">Derrota</option>
            </select>
            <label for="g2-result">Resultado do Game 2:</label>
            <select id="g2-result" required disabled>
                <option value="" disabled selected>G2</option>
                <option value="win">Vitória</option>
                <option value="loss">Derrota</option>
            </select>
                        <label for="g3-result">Resultado do Game 3:</label>
            <select id="g3-result" disabled>
                <option value="not_played" selected>Não Jogou (2-0 ou 0-2)</option>
                <option value="win">Vitória</option>
                <option value="loss">Derrota</option>
            </select>
                        <button type="submit" disabled id="submit-match">Registrar Partida</button>
        </form>
        <div class="stats-section general-stats">
            <h2>Estatísticas Gerais - <span id="current-deck-name">Selecione um Deck</span></h2>
            <div class="stats-item">
                <div class="stats-value" id="wr-match-geral">--%</div>
                <div class="stats-label">Win Rate (Matches)</div>
            </div>
            <div class="stats-item">
                <div class="stats-value" id="wr-game-geral">--%</div>
                <div class="stats-label">Win Rate (Games)</div>
            </div>
                        <h4>Win Rate por Game (G1/G2/G3)</h4>
            <div class="stats-section">
                 <div class="stats-item">
                    <div class="stats-value" id="wr-g1-geral">--%</div>
                    <div class="stats-label">Game 1 WR</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="wr-g2-geral">--%</div>
                    <div class="stats-label">Game 2 WR</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="wr-g3-geral">--%</div>
                    <div class="stats-label">Game 3 WR</div>
                </div>
            </div>
        </div>
        <form id="matchup-stats-form">
            <h2>Estatísticas por Matchup</h2>
            <label for="matchup-select">Selecione um Matchup:</label>
            <select id="matchup-select" disabled>
                <option value="" selected>Selecione um Deck...</option>
            </select>
        </form>
                <div id="matchup-stats-display">
            <h3>Matchup contra: <span id="matchup-name"></span></h3>
                        <div class="stats-section">
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-match">--%</div>
                    <div class="stats-label">Match Win Rate</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-game">--%</div>
                    <div class="stats-label">Game Win Rate Total</div>
                </div>
            </div>
                        <h4>Win Rate por Game (G1/G2/G3)</h4>
            <div class="stats-section">
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-g1">--%</div>
                    <div class="stats-label">Game 1 WR</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-g2">--%</div>
                    <div class="stats-label">Game 2 WR</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-g3">--%</div>
                    <div class="stats-label">Game 3 WR</div>
                </div>
            </div>
        </div>
        <div id="status" class="loading">Inicie selecionando um usuário.</div>
    </div>
    
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

    <script>
        // CONFIGURAÇÃO FIREBASE EMBUTIDA
        const firebaseConfig = {
            apiKey: "AIzaSyDXVYDMwvnUoCUMTlvh8egzqS06_o497y8",
            authDomain: "mtg-tracker-ea7a2.firebaseapp.com",
            databaseURL: "https://mtg-tracker-ea7a2-default-rtdb.firebaseio.com",
            projectId: "mtg-tracker-ea7a2",
            storageBucket: "mtg-tracker-ea7a2.firebasestorage.app",
            messagingSenderId: "365839696243",
            appId: "1:365839696243:web:72d8c6b1d4acafbc7c506",
            measurementId: "G-029H8PTYRH"
        };

        // VARIÁVEIS MULTI-USUÁRIO
        let currentUser = null;
        const USERS = ['Chico', 'Capi', 'Maciel', 'Avelã', 'Gominho'];
        const NOVO_USUARIO_OPCAO = 'NOVO_USUARIO';
        
        const NOVO_DECK_OPCAO = 'NOVO_DECK';
        const NOVA_MATCHUP_OPCAO = 'NOVA_MATCHUP';
        
        // --- METAGAMES POR FORMATO ---
        const METAGAME_DECKS_BY_FORMAT = {
            'Modern': [
                'Esper Goryo\'s', 'Tameshi Belcher', 'Boros Energy', 'Eldrazi Tron',
                'Izzet Affinity', 'Esper Blink', 'Simic Neoform', 'Domain Zoo',
                'Azorius Control', 'Mono-Green Tron', 'Murktide Regent', 'Rhinos',
                'Living End', 'Yawgmoth', 'Amulet Titan', 'Outro'
            ],
            'Pioneer': [
                'Rakdos Midrange', 'Izzet Phoenix', 'Azorius Control', 'Lotus Field Combo',
                'Gruul Prowess', 'Boros Convoke', 'Abzan Greasefang', 'Mono Black Midrange',
                'Selesnya Angels', 'Niv to Light', 'Outro'
            ],
            'Legacy': [
                'Izzet Delver', 'Dimir Reanimator', 'Eldrazi', 'Red Stompy',
                'Dimir Tempo', 'Azorius Control', 'Jeskai Control',
                '4c Initiative', 'The EPIC Storm', 'Outro'
            ],
            'Standard': [
                'Izzet Cauldron', 'Dimir Midrange', 'Mono Red Aggro', 'Boros Burn',
                'Azorius Control', 'Mono Black', 'Gruul Landfall', 'Jeskai Artifacts',
                'Esper Control', 'Outro'
            ],
            'Pauper': [
                'Mono-Blue Terror', 'Madness Burn', 'Grixis Affinity',
                'Mono-Black Sacrifice', 'Golgari Gardens', 'Jeskai Ephemerate',
                'Spy Combo', 'Burn', 'Elves', 'Outro'
            ]
        };
        // ------------------------------------

        // VARIÁVEIS DE CONEXÃO E DADOS
        let firebaseApp = null;
        let dbRef = null; 
        // allData agora armazena os dados aninhados: { 'Modern': { 'decks': { 'Amulet Titan': {...} } }, 'Pioneer': { ... } }
        let allData = {}; 

        let currentDeck = null;
        let currentFormat = null; // Armazena o formato selecionado

        const userSelect = document.getElementById('user-select');
        const currentFormatSelect = document.getElementById('current-format-select');
        const currentDeckSelect = document.getElementById('current-deck-select');
        const deckOponenteSelect = document.getElementById('deck-oponente-select');
        const matchupSelect = document.getElementById('matchup-select');
        const statusElement = document.getElementById('status');
        const form = document.getElementById('matchup-form');
        const novaMatchupContainer = document.getElementById('nova-matchup-container');
        const novaMatchupInput = document.getElementById('nova-matchup-input');
        const novoDeckContainer = document.getElementById('novo-deck-container');
        const novoDeckInput = document.getElementById('novo-deck-input');
        const novoUsuarioContainer = document.getElementById('novo-usuario-container');
        const novoUsuarioInput = document.getElementById('novo-usuario-input');
        const displayDiv = document.getElementById('matchup-stats-display');
        const fileInput = document.getElementById('file-input');
        
        // Elementos a serem desativados/ativados
        const controlsToToggle = [
            currentFormatSelect, currentDeckSelect, deckOponenteSelect, matchupSelect,
            document.getElementById('g1-result'), document.getElementById('g2-result'),
            document.getElementById('g3-result'), document.getElementById('submit-match'),
            document.getElementById('export-btn'), document.getElementById('import-btn')
        ];


        // FUNÇÕES DE CONEXÃO FIREBASE
        function initializeFirebase(config) {
            try {
                if (!firebaseApp) {
                    firebaseApp = firebase.initializeApp(config);
                }
                
                statusElement.textContent = 'Conectado ao Firebase. Selecione um usuário.';
                statusElement.className = 'success';
            } catch (e) {
                console.error("Erro ao inicializar o Firebase:", e);
                statusElement.textContent = `Erro ao inicializar o Firebase: ${e.message}`;
                statusElement.className = 'error';
            }
        }
        
        // NOVO: dbRef aponta para a raiz do usuário. allData contém todos os formatos.
        function loadUserData(username) {
            if (!firebaseApp) return;

            // dbRef agora aponta para a raiz de todos os dados do usuário (users/{username})
            dbRef = firebaseApp.database().ref(`users/${username}`);
            currentUser = username;
            
            // Ativa controles após a seleção do usuário
            controlsToToggle.forEach(control => {
                // Deixa o seletor de formato ATIVO
                if (control.id === 'current-format-select') {
                    control.disabled = false; 
                } else if (control.id !== 'export-btn' && control.id !== 'import-btn') {
                    // Outros controles (decks, partidas) dependem do formato/deck, então ficam desativados inicialmente
                    control.disabled = true;
                }
            });

            statusElement.textContent = `Carregando dados de ${username}...`;
            statusElement.className = 'loading';
            
            // Listener para carregar e atualizar os dados em tempo real
            // A estrutura de allData será: { FormatName: { decks: { DeckName: { matches } } } }
            dbRef.on('value', (snapshot) => {
                allData = snapshot.val() || { };
                
                // Re-popula o seletor de formato, que dispara a lógica de seleção de deck
                popularFormatSelector(); 
                
                // Tenta manter o deck e formato selecionados
                const lastFormat = localStorage.getItem('lastFormat');
                const lastDeck = localStorage.getItem('lastDeck');

                if (lastFormat && allData[lastFormat]) {
                    currentFormatSelect.value = lastFormat;
                    currentFormat = lastFormat;
                    onFormatChange(false); // Não salva o formato novamente

                    if (lastDeck && getCurrentDecks(lastFormat)[lastDeck]) {
                        currentDeck = lastDeck;
                        currentDeckSelect.value = lastDeck;
                        onDeckChange(lastDeck);
                    } else {
                        // Se o deck não existir mais, reseta o deck
                        currentDeck = null;
                        onDeckChange(null);
                    }
                } else {
                    currentFormat = null;
                    currentDeck = null;
                    onFormatChange(false);
                }

                // Ativa os botões de I/O após o primeiro load de dados
                document.getElementById('export-btn').disabled = false;
                document.getElementById('import-btn').disabled = false;

                statusElement.textContent = `Usuário: ${currentUser}. Dados atualizados (Cloud).`;
                statusElement.className = 'success';
            }, (error) => {
                console.error("Erro de conexão com o Firebase:", error);
                statusElement.textContent = `Erro ao carregar dados do usuário ${username}: ${error.message}`;
                statusElement.className = 'error';
            });
        }
        
        function popularUserSelector() {
            userSelect.innerHTML = '';
            userSelect.appendChild(new Option('Selecione seu Nome', '', true, true));

            USERS.forEach(name => {
                userSelect.appendChild(new Option(name, name));
            });
            userSelect.appendChild(new Option('--- Novo Usuário ---', NOVO_USUARIO_OPCAO));
            
            // Tenta pré-selecionar o último usuário usado (se houver)
            const lastUser = localStorage.getItem('lastUser');
            if (lastUser && USERS.includes(lastUser)) {
                userSelect.value = lastUser;
                loadUserData(lastUser);
            }
        }
        
        function setNovoUsuario() {
            const nomeUsuario = novoUsuarioInput.value.trim();
            if (!nomeUsuario || USERS.includes(nomeUsuario)) {
                statusElement.textContent = 'Nome de usuário inválido ou já existe.';
                statusElement.className = 'error';
                return;
            }
            
            USERS.push(nomeUsuario); // Adiciona na lista temporariamente
            popularUserSelector(); // Repopula o dropdown
            userSelect.value = nomeUsuario; // Seleciona o novo usuário
            novoUsuarioContainer.style.display = 'none';
            novoUsuarioInput.value = '';
            
            // Salva o usuário no localStorage para persistência e carrega os dados
            localStorage.setItem('lastUser', nomeUsuario);
            loadUserData(nomeUsuario);
        }

        // Popula o seletor de Formato
        function popularFormatSelector() {
            currentFormatSelect.innerHTML = '';
            currentFormatSelect.appendChild(new Option('Selecione o Formato', '', true, true));
            
            const formats = Object.keys(METAGAME_DECKS_BY_FORMAT).sort();
            formats.forEach(format => {
                currentFormatSelect.appendChild(new Option(format, format));
            });
        }

        // Retorna um objeto de decks para o formato atual ou vazio
        function getCurrentDecks(format) {
            return allData[format] && allData[format].decks ? allData[format].decks : {};
        }

        // Ação ao mudar o formato
        function onFormatChange(shouldSave = true) {
            currentFormat = currentFormatSelect.value;
            if (shouldSave) {
                 localStorage.setItem('lastFormat', currentFormat); // Salva o formato
            }
            
            // Resetar o deck atual, forçando a repopulação
            currentDeck = null;
            currentDeckSelect.value = '';

            if (currentFormat) {
                // Ativa os controles de partida
                currentDeckSelect.disabled = false;
                
                // Força a repopulação dos decks e desativa temporariamente os controles de partida
                popularDeckSelector(); 
                
                deckOponenteSelect.disabled = true;
                document.getElementById('g1-result').disabled = true;
                document.getElementById('g2-result').disabled = true;
                document.getElementById('g3-result').disabled = true;
                document.getElementById('submit-match').disabled = true;
            } else {
                // Desativa os seletores de deck e partida se o formato não estiver selecionado
                currentDeckSelect.disabled = true;
                deckOponenteSelect.disabled = true;
                matchupSelect.disabled = true;
                document.getElementById('g1-result').disabled = true;
                document.getElementById('g2-result').disabled = true;
                document.getElementById('g3-result').disabled = true;
                document.getElementById('submit-match').disabled = true;
                
                currentDeckSelect.innerHTML = '<option value="" disabled selected>Selecione um Formato Primeiro</option>';
            }
            
            updateStatsDisplay(null); // Limpa as estatísticas
        }


        // FUNÇÕES DE DADOS (AGORA DEPENDEM DE currentUser, currentFormat E dbRef)

        function loadData() {
            initializeFirebase(firebaseConfig);
        }

        // NOVO: Retorna as partidas do deck ATUAL no formato ATUAL
        function getCurrentMatches() {
            if (!currentFormat || !currentDeck) return {};
            // Navega na nova estrutura: allData[Format].decks[Deck]
            return allData[currentFormat]?.decks?.[currentDeck] || {};
        }

        // NOVO: Função centralizada para lidar com a mudança ou seleção de deck
        function onDeckChange(deckName) {
            localStorage.setItem('lastDeck', deckName); // Salva o deck
            
            if (deckName === NOVO_DECK_OPCAO) {
                currentDeck = null; // Desmarcado até ser criado
                novoDeckContainer.style.display = 'block';
                novoDeckInput.focus();
                // Desativa a interface de registro de partida até o novo deck ser criado/registrado
                deckOponenteSelect.disabled = true;
                document.getElementById('submit-match').disabled = true;
            } else if (deckName) {
                currentDeck = deckName;
                novoDeckContainer.style.display = 'none';
                
                // Reativa a interface de registro de partida
                deckOponenteSelect.disabled = false;
                document.getElementById('g1-result').disabled = false;
                document.getElementById('g2-result').disabled = false;
                document.getElementById('g3-result').disabled = false;
                document.getElementById('submit-match').disabled = false;

                // Atualiza as outras listas e estatísticas
                popularDropdowns(); // Matchup list do oponente e stats
                updateStatsDisplay(null); // Estatísticas gerais
            } else {
                // Se a seleção for limpa (placeholder)
                currentDeck = null;
                novoDeckContainer.style.display = 'none';
                popularDropdowns(); // Limpa/Desativa listas dependentes
                updateStatsDisplay(null);
            }
        }


        function popularDeckSelector() {
            if (!currentFormat) return; 

            currentDeckSelect.innerHTML = '';
            currentDeckSelect.appendChild(new Option('Selecione seu Deck Atual', '', true, true));
            
            const metagameDecks = METAGAME_DECKS_BY_FORMAT[currentFormat] || [];
            
            const uniqueDeckOptions = new Set(metagameDecks);
            
            // Pega os decks existentes do usuário SOMENTE para o formato atual
            const existingUserDecks = getCurrentDecks(currentFormat);
            const existingUserDeckNames = Object.keys(existingUserDecks).sort();
            
            existingUserDeckNames.forEach(name => {
                uniqueDeckOptions.add(name);
            });
            
            // Remove "Outro" da lista de decks próprios
            uniqueDeckOptions.delete('Outro');
            
            const finalDeckList = Array.from(uniqueDeckOptions).sort();

            finalDeckList.forEach(name => {
                currentDeckSelect.appendChild(new Option(name, name));
            });
            
            currentDeckSelect.appendChild(new Option('--- Criar Novo Deck ---', NOVO_DECK_OPCAO));
            
            // Tenta selecionar o deck atual (definido na carga inicial ou importação)
            if (currentDeck && (finalDeckList.includes(currentDeck) || currentDeck === NOVO_DECK_OPCAO)) {
                currentDeckSelect.value = currentDeck;
                if (currentDeck !== NOVO_DECK_OPCAO) {
                     onDeckChange(currentDeck);
                }
            } else {
                currentDeck = null;
                onDeckChange(null);
            }
        }

        function criarNovoDeck() {
            const nomeDeck = novoDeckInput.value.trim();
            if (!nomeDeck || !dbRef || !currentFormat) {
                statusElement.textContent = 'Erro: Selecione um usuário e formato primeiro.';
                statusElement.className = 'error';
                return;
            }
            if (getCurrentDecks(currentFormat)[nomeDeck]) {
                statusElement.textContent = 'Esse deck já existe nesse formato!';
                statusElement.className = 'error';
                return;
            }
            
            currentDeck = nomeDeck; 
            novoDeckContainer.style.display = 'none';
            novoDeckInput.value = '';
            
            // O Firebase será atualizado quando a primeira partida for adicionada.
            // Apenas atualiza o seletor localmente.
            popularDeckSelector(); 
            currentDeckSelect.value = nomeDeck; 
            onDeckChange(nomeDeck);
            
            statusElement.textContent = `Deck "${nomeDeck}" pronto para registro no formato ${currentFormat}!`;
            statusElement.className = 'success';
        }

        function addMatch(newMatch) {
            if (!currentDeck || !currentFormat || !dbRef) {
                statusElement.textContent = 'Erro: Selecione um formato e um deck.';
                statusElement.className = 'error';
                return;
            }
            
            // NOVO CAMINHO: users/{user}/{format}/decks/{deck}
            const matchRef = dbRef.child(currentFormat).child('decks').child(currentDeck);

            matchRef.push(newMatch)
                .then(() => {
                    statusElement.textContent = 'Partida registrada com sucesso! Sincronizando...';
                    statusElement.className = 'loading';
                })
                .catch(error => {
                    statusElement.textContent = `Erro ao salvar partida: ${error.message}`;
                    statusElement.className = 'error';
                });
        }
        
        // Exporta a estrutura completa de allData (todos os formatos)
        function exportData() {
            if (!currentUser) return;
            
            const data = JSON.stringify(allData, null, 2);
            if (data === '{}' || Object.keys(allData).length === 0) {
                statusElement.textContent = 'Não há dados para exportar.';
                statusElement.className = 'error';
                return;
            }
            const filename = `${currentUser}_multi_deck_tracker_data.json`;
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
                        
            statusElement.textContent = `Dados de ${currentUser} exportados com sucesso!`;
            statusElement.className = 'success';
        }
        
        function importData(jsonString) {
            if (!dbRef || !currentUser || !currentFormat) {
                statusElement.textContent = 'Erro: Selecione um usuário E um formato para importar dados.';
                statusElement.className = 'error';
                return;
            }
            try {
                const importedDataRaw = JSON.parse(jsonString);                                
                
                if (typeof importedDataRaw !== 'object' || Array.isArray(importedDataRaw)) {
                    statusElement.textContent = 'Erro: O arquivo deve ser um objeto JSON válido.';
                    statusElement.className = 'error';
                    return;
                }
                
                // NOVO: Transformação para a nova estrutura de formato
                let dataToSave;
                let firstImportedDeck = null;

                // Verifica se a estrutura é a nova (chave é um formato, e contém um 'decks' dentro)
                const isNewStructure = Object.keys(importedDataRaw).some(key => importedDataRaw[key] && importedDataRaw[key].decks);

                if (isNewStructure) {
                    // Se for a nova estrutura, apenas sobrescrevemos os dados
                    dataToSave = importedDataRaw;
                    // Tenta encontrar o primeiro deck no formato atual
                    const currentFormatDecks = dataToSave[currentFormat]?.decks;
                    if (currentFormatDecks) {
                        firstImportedDeck = Object.keys(currentFormatDecks)[0];
                    }
                } else {
                    // Se for a estrutura antiga (DeckName: { matches }), reestrutura
                    firstImportedDeck = Object.keys(importedDataRaw)[0];
                    dataToSave = {
                        ...allData, // Mantém os formatos existentes
                        [currentFormat]: {
                            decks: importedDataRaw // Coloca todos os decks importados sob o formato atual
                        }
                    };
                    statusElement.textContent += ` (Importando estrutura antiga, atribuindo ao formato: ${currentFormat})`;
                }

                // Define o nó raiz de 'users/{username}' do usuário atual com os dados
                dbRef.set(dataToSave)
                    .then(() => {
                        // Força a seleção do primeiro deck encontrado após a importação, se houver
                        if (firstImportedDeck) {
                            currentDeck = firstImportedDeck;
                            popularDeckSelector(); // Repopula e seleciona
                            currentDeckSelect.value = firstImportedDeck;
                            onDeckChange(firstImportedDeck);
                        }

                        statusElement.textContent = `Dados importados para ${currentUser} e sincronizados com o Firebase!`;
                        statusElement.className = 'success';
                    })
                    .catch(e => {
                        statusElement.textContent = `Erro ao importar para o Firebase: ${e.message}`;
                        statusElement.className = 'error';
                    });
                
            } catch (e) {
                statusElement.textContent = `Erro ao analisar o arquivo de importação: ${e.message}`;
                statusElement.className = 'error';
            }
        }


        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => importData(e.target.result);
            reader.onerror = () => {
                statusElement.textContent = 'Erro ao ler o arquivo';
                statusElement.className = 'error';
            };
            reader.readAsText(file);
            event.target.value = null;
        }

        function calculateStats(filteredData) {
            // Note: O Firebase armazena partidas como um objeto de objetos. Convertemos para array aqui.
            const matchesArray = Object.values(filteredData || {});
            
            let totalMatches = 0, matchesWon = 0, totalGames = 0, gamesWon = 0;
            let g1Total = 0, g1Won = 0, g2Total = 0, g2Won = 0, g3Total = 0, g3Won = 0;

            for (const match of matchesArray) {
                // Não há mais filtro de formato, pois getCurrentMatches() já filtra
                
                const g1 = match.g1Result ? match.g1Result.toLowerCase() : '';
                const g2 = match.g2Result ? match.g2Result.toLowerCase() : '';
                const g3 = match.g3Result ? match.g3Result.toLowerCase() : 'not_played';

                if (g1) { g1Total++; if (g1 === 'win') { g1Won++; gamesWon++; } }
                if (g2) { g2Total++; if (g2 === 'win') { g2Won++; gamesWon++; } }
                if (g3 !== 'not_played' && g3) { g3Total++; if (g3 === 'win') { g3Won++; gamesWon++; } }

                totalMatches++;
                let wins = (g1 === 'win' ? 1 : 0) + (g2 === 'win' ? 1 : 0) + (g3 === 'win' ? 1 : 0);
                if (wins >= 2) matchesWon++;
            }

            totalGames = g1Total + g2Total + g3Total;

            const formatWR = (num, den) => den > 0 ? (num / den * 100).toFixed(1) + '%' : '--%';
            
            return {
                totalMatches: totalMatches, // Retorna o total para atualizar o status
                generalWinRate: formatWR(matchesWon, totalMatches),
                gameWinRate: formatWR(gamesWon, totalGames),
                g1WinRate: formatWR(g1Won, g1Total),
                g2WinRate: formatWR(g2Won, g2Total),
                g3WinRate: formatWR(g3Won, g3Total)
            };
        }

        function updateStatsDisplay(matchupName = null) {
            const currentMatches = getCurrentMatches();
            let filteredMatches;

            if (matchupName) {
                filteredMatches = Object.values(currentMatches).filter(m => m.deckOponente === matchupName);
                document.getElementById('matchup-name').textContent = matchupName;
                displayDiv.style.display = 'block';
            } else {
                filteredMatches = currentMatches;
                displayDiv.style.display = 'none';
            }

            const stats = calculateStats(filteredMatches);

            if (matchupName) {
                document.getElementById('matchup-wr-match').textContent = stats.generalWinRate;
                document.getElementById('matchup-wr-game').textContent = stats.gameWinRate;
                document.getElementById('matchup-wr-g1').textContent = stats.g1WinRate;
                document.getElementById('matchup-wr-g2').textContent = stats.g2WinRate;
                document.getElementById('matchup-wr-g3').textContent = stats.g3WinRate;
            } else {
                document.getElementById('wr-match-geral').textContent = stats.generalWinRate;
                document.getElementById('wr-game-geral').textContent = stats.gameWinRate;
                document.getElementById('wr-g1-geral').textContent = stats.g1WinRate;
                document.getElementById('wr-g2-geral').textContent = stats.g2WinRate;
                document.getElementById('wr-g3-geral').textContent = stats.g3WinRate;

                const matchCount = stats.totalMatches;
                document.getElementById('current-deck-name').textContent = currentDeck || 'Nenhum';
                
                if (currentDeck && matchCount > 0) {
                    statusElement.textContent = `Usuário: ${currentUser}. ${currentDeck} (${currentFormat}): ${matchCount} partidas registradas (Cloud).`;
                    statusElement.className = 'success';
                } else if (currentDeck && matchCount === 0) {
                    statusElement.textContent = `Usuário: ${currentUser}. Deck "${currentDeck}" (${currentFormat}) pronto. Registre sua primeira partida!`;
                    statusElement.className = 'error';
                } else if (currentUser && !currentFormat) {
                     statusElement.textContent = `Usuário: ${currentUser}. Selecione um Formato!`;
                     statusElement.className = 'error';
                }
            }
        }

        function popularDropdowns() {
            // Esta função atualiza o seletor de OPONENTES e o seletor de STATS por Matchup
            if (!currentFormat || !currentDeck) {
                deckOponenteSelect.innerHTML = '<option value="" disabled selected>Selecione um Deck Primeiro</option>';
                matchupSelect.innerHTML = '<option value="" disabled selected>Selecione um Deck...</option>';
                matchupSelect.disabled = true; 
                return;
            }

            const currentMatches = getCurrentMatches();
            
            // 1. Pega os decks do metagame do formato selecionado
            let uniqueDecks = [...(METAGAME_DECKS_BY_FORMAT[currentFormat] || [])];
            
            // 2. Adiciona os decks oponentes já registrados no Firebase
            const recordedDecks = new Set(Object.values(currentMatches)
                .map(m => m.deckOponente)
            );

            recordedDecks.forEach(deck => {
                if (!uniqueDecks.includes(deck)) uniqueDecks.push(deck);
            });
            
            // Prepara a lista final para o seletor de Oponente
            const outroIndex = uniqueDecks.indexOf('Outro');
            if (outroIndex > -1) {
                 uniqueDecks.splice(outroIndex, 1);
            }

            uniqueDecks.sort();

            // Popula seletor de Deck Oponente
            deckOponenteSelect.innerHTML = '';
            deckOponenteSelect.appendChild(new Option('Selecione o Deck Oponente', '', true, true));
            uniqueDecks.forEach(name => {
                deckOponenteSelect.appendChild(new Option(name, name));
            });
            deckOponenteSelect.appendChild(new Option('--- Nova Matchup (Manual) ---', NOVA_MATCHUP_OPCAO));


            // Popula seletor de Estatísticas por Matchup (somente decks registrados)
            const statsDecks = [...recordedDecks].sort();
            matchupSelect.innerHTML = '';
            matchupSelect.appendChild(new Option('Selecione um Matchup...', ''));
            statsDecks.forEach(name => matchupSelect.appendChild(new Option(name, name)));
            
            // Habilita a aba de estatísticas se houver matchups registradas
            if (statsDecks.length > 0) {
                matchupSelect.disabled = false;
            } else {
                matchupSelect.disabled = true;
            }
        }

        // Event Listeners
        
        // NOVO EVENTO: Seleção de Formato
        currentFormatSelect.addEventListener('change', () => onFormatChange(true));

        // NOVO EVENTO: Seleção de Usuário
        userSelect.addEventListener('change', (e) => {
            const selectedUser = e.target.value;
            localStorage.setItem('lastUser', selectedUser); // Salva o último usuário
            
            if (selectedUser === NOVO_USUARIO_OPCAO) {
                novoUsuarioContainer.style.display = 'block';
                novoUsuarioInput.focus();
                // Desativa os controles
                controlsToToggle.forEach(control => control.disabled = true);
            } else {
                novoUsuarioContainer.style.display = 'none';
                loadUserData(selectedUser);
            }
        });
        
        // USO DE FUNÇÃO CENTRALIZADA onDeckChange
        currentDeckSelect.addEventListener('change', (e) => {
            onDeckChange(e.target.value);
        });

        form.addEventListener('submit', (e) => {
            e.preventDefault();
                        
            if (!currentDeck || !currentFormat) {
                statusElement.textContent = 'Selecione um Formato e um Deck primeiro!';
                statusElement.className = 'error';
                return;
            }
            
            let deckOponente = deckOponenteSelect.value;
            
            if (deckOponente === NOVA_MATCHUP_OPCAO) {
                deckOponente = novaMatchupInput.value.trim();
                if (!deckOponente) {
                    statusElement.textContent = 'Digite o nome da nova matchup!';
                    statusElement.className = 'error';
                    return;
                }
            }
            
            const g1Result = document.getElementById('g1-result').value;
            const g2Result = document.getElementById('g2-result').value;
            const g3Result = document.getElementById('g3-result').value;
            
            if (!deckOponente || !g1Result || !g2Result) {
                statusElement.textContent = 'Preencha todos os campos obrigatórios!';
                statusElement.className = 'error';
                return;
            }

            const newMatch = {
                timestamp: new Date().toISOString(),
                // deckFormat: currentFormat, // Não precisa mais do formato no nó, pois o nó pai já o define
                deckProprio: currentDeck,
                deckOponente: deckOponente,
                g1Result: g1Result,
                g2Result: g2Result,
                g3Result: g3Result
            };
                        
            addMatch(newMatch);
            
            form.reset();
            document.getElementById('g3-result').value = 'not_played';
            novaMatchupContainer.style.display = 'none';
        });

        matchupSelect.addEventListener('change', (e) => {
            const selectedMatchup = e.target.value;
            if (selectedMatchup) {
                updateStatsDisplay(selectedMatchup);
            } else {
                displayDiv.style.display = 'none';
                updateStatsDisplay(null);
            }
        });

        deckOponenteSelect.addEventListener('change', (e) => {
            if (e.target.value === NOVA_MATCHUP_OPCAO) {
                novaMatchupContainer.style.display = 'block';
                novaMatchupInput.setAttribute('required', 'required');
                novaMatchupInput.focus();
            } else {
                novaMatchupContainer.style.display = 'none';
                novaMatchupInput.removeAttribute('required');
                novaMatchupInput.value = '';
            }
        });

        fileInput.addEventListener('change', handleFileSelect, false);

        // Initialization
        document.addEventListener('DOMContentLoaded', () => {
            loadData(); 
            popularUserSelector(); // Popula o dropdown de usuários primeiro
        });
    </script>
</body>
</html>
