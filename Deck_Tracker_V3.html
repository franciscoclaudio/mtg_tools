<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Deck Match Tracker</title>
    <link rel="stylesheet" href="styles/Deck_Tracker_styles.css">
    
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>Multi-Deck Match Tracker</h1>
            <h2>Rastreamento para Múltiplos Decks (Cloud)</h2>
        </header>
        
        <div class="user-selector">
            <label for="user-select">Selecione o Usuário:</label>
            <select id="user-select" required>
                <option value="">Selecione seu Nome</option>
            </select>
            <div id="novo-usuario-container">
                <label for="novo-usuario-input">Nome do Novo Usuário:</label>
                <input type="text" id="novo-usuario-input" placeholder="Ex: Gominho">
                <button type="button" onclick="setNovoUsuario()" class="btn-create-user">Entrar</button>
            </div>
        </div>
        <div class="format-selector">
            <label for="current-format-select">Selecione o formato:</label>
            <select id="current-format-select" required disabled>
                <option value="" disabled selected>Selecione o Formato</option>
            </select>
        </div>
        <div class="deck-selector">
            <label for="current-deck-select">Selecione seu Deck:</label>
            <select id="current-deck-select" required disabled>
                <option value="">Selecione o Deck</option>
            </select>
            <div id="novo-deck-container">
                <label for="novo-deck-input">Nome do Novo Deck:</label>
                <input type="text" id="novo-deck-input" placeholder="Ex: Boros Energy">
                <button type="button" onclick="criarNovoDeck()" class="btn-create-deck">Criar Deck</button>
            </div>
        </div>

        <form id="match-form">
            <fieldset id="match-fieldset" disabled>
                <legend>Registrar Nova Partida</legend>

                <label for="deck-oponente-select">Deck Oponente:</label>
                <select id="deck-oponente-select" required disabled>
                    <option value="">Selecione o Deck</option>
                </select>

                <div id="nova-matchup-container">
                    <label for="nova-matchup-input">Nova Matchup:</label>
                    <input type="text" id="nova-matchup-input" placeholder="Ex: Boros Energy">
                </div>
                
                <label for="play-draw-select">Você estava:</label>
                <select id="play-draw-select" required disabled>
                    <option value="" disabled selected>Play ou Draw?</option>
                    <option value="play">Play</option>
                    <option value="draw">Draw</option>
                </select>
                <label for="g1-result">Resultado do Game 1:</label>
                <select id="g1-result" required disabled>
                    <option value="" disabled selected>Selecione o Resultado</option>
                    <option value="win">Vitória</option>
                    <option value="loss">Derrota</option>
                </select>

                <label for="g2-result">Resultado do Game 2:</label>
                <select id="g2-result" required disabled>
                    <option value="" disabled selected>Selecione o Resultado</option>
                    <option value="win">Vitória</option>
                    <option value="loss">Derrota</option>
                </select>

                <label for="g3-result">Resultado do Game 3:</label>
                <select id="g3-result" required disabled>
                    <option value="not_played" selected>Não Jogou</option>
                    <option value="win">Vitória</option>
                    <option value="loss">Derrota</option>
                </select>

                <button type="submit" id="submit-match" disabled>Registrar Partida</button>
            </fieldset>
        </form>

        <div id="stats-display" class="stats-container">
            <h3>Estatísticas Gerais do Deck: <span id="current-deck-name"></span></h3>
            
            <h4>Win Rate Geral</h4>
            <div class="stats-section">
                <div class="stats-item">
                    <div class="stats-value" id="wr-match-geral">--%</div>
                    <div class="stats-label">Match WR</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="wr-game-geral">--%</div>
                    <div class="stats-label">Game WR</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="wr-g1-geral">--%</div>
                    <div class="stats-label">Game 1 WR</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="wr-g2-geral">--%</div>
                    <div class="stats-label">Game 2 WR</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="wr-g3-geral">--%</div>
                    <div class="stats-label">Game 3 WR</div>
                </div>
            </div>

            <h4>Win Rate Play vs. Draw</h4>
            <div class="stats-section">
                 <div class="stats-item">
                    <div class="stats-value" id="wr-play-geral">--%</div>
                    <div class="stats-label">Win Rate no Play</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="wr-draw-geral">--%</div>
                    <div class="stats-label">Win Rate no Draw</div>
                </div>
            </div>
            </div>

        <form id="matchup-stats-form">
            <label for="matchup-select">Ver Estatísticas de Matchup:</label>
            <select id="matchup-select" disabled>
                <option value="">Selecione uma Matchup</option>
            </select>
        </form>

        <div id="matchup-stats-display" class="stats-container" style="display: none;">
            <h3>Estatísticas do Deck contra: <span id="matchup-name"></span></h3>
            
            <h4>Win Rate Matchup</h4>
            <div class="stats-section">
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-match">--%</div>
                    <div class="stats-label">Match WR</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-game">--%</div>
                    <div class="stats-label">Game WR</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-g1">--%</div>
                    <div class="stats-label">Game 1 WR</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-g2">--%</div>
                    <div class="stats-label">Game 2 WR</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-g3">--%</div>
                    <div class="stats-label">Game 3 WR</div>
                </div>
            </div>

            <h4>Win Rate Play vs. Draw</h4>
            <div class="stats-section">
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-play">--%</div>
                    <div class="stats-label">Win Rate no Play</div>
                </div>
                <div class="stats-item">
                    <div class="stats-value" id="matchup-wr-draw">--%</div>
                    <div class="stats-label">Win Rate no Draw</div>
                </div>
            </div>
            </div>

        <div id="status" class="loading">Inicie selecionando um usuário.</div>

        <div class="utility-container">
            <h4>Utilitários</h4>
            <button id="export-btn" disabled>Exportar Dados</button>
            <input type="file" id="file-input" accept=".json" style="display: none;">
            <button id="import-btn" disabled>Importar Dados</button>
        </div>
    </div>

    <script>
        // ===============================================
        // VARIÁVEIS GLOBAIS E CONFIGURAÇÃO
        // ===============================================

        // **Atenção: Substitua pelos seus dados de configuração do Firebase**
        const firebaseConfig = {
          apiKey: "AIzaSyDXVYDMwvnUoCUMTlvh8egzqS06_o497y8",
          authDomain: "mtg-tracker-ea7a2.firebaseapp.com",
          databaseURL: "https://mtg-tracker-ea7a2-default-rtdb.firebaseio.com",
          projectId: "mtg-tracker-ea7a2",
          storageBucket: "mtg-tracker-ea7a2.firebasestorage.app",
          messagingSenderId: "365839696243",
          appId: "1:365839696243:web:72d8c86b1d4acafbc7c506",
          measurementId: "G-029H8PTYRH"
        };
        // Inicializa o Firebase
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        } else {
            firebase.app(); // Se já estiver inicializado, use o existente
        }

        const db = firebase.database();
        const NOVA_MATCHUP_OPCAO = 'NOVA_MATCHUP';
        const NOVO_DECK_OPCAO = 'NOVO_DECK';

        let currentUser = localStorage.getItem('currentUser') || null;
        let currentFormat = localStorage.getItem('currentFormat') || null;
        let currentDeck = localStorage.getItem('currentDeck') || null;
        let allData = {}; // Armazena todos os dados do usuário logado: { format: { decks: {...}, matchups: {...} } }
        let dbRef = null; // Referência dinâmica ao nó 'users/{currentUser}'

        // Elementos do DOM
        const userSelect = document.getElementById('user-select');
        const novoUsuarioContainer = document.getElementById('novo-usuario-container');
        const novoUsuarioInput = document.getElementById('novo-usuario-input');
        const currentFormatSelect = document.getElementById('current-format-select');
        const currentDeckSelect = document.getElementById('current-deck-select');
        const novoDeckContainer = document.getElementById('novo-deck-container');
        const novoDeckInput = document.getElementById('novo-deck-input');
        const deckOponenteSelect = document.getElementById('deck-oponente-select');
        const matchupSelect = document.getElementById('matchup-select');
        const matchForm = document.getElementById('match-form');
        const novaMatchupContainer = document.getElementById('nova-matchup-container');
        const novaMatchupInput = document.getElementById('nova-matchup-input');
        const statusElement = document.getElementById('status');
        const displayDiv = document.getElementById('matchup-stats-display');
        const fileInput = document.getElementById('file-input');
        
        // ===============================================
        // FUNÇÕES AUXILIARES DE ESTADO
        // ===============================================

        function toggleControls(enable) {
            // Elementos a serem desativados/ativados
            const controlsToToggle = [
                currentFormatSelect, currentDeckSelect, deckOponenteSelect, matchupSelect,
                document.getElementById('play-draw-select'),
                document.getElementById('g1-result'), document.getElementById('g2-result'),
                document.getElementById('g3-result'), document.getElementById('submit-match'),
                document.getElementById('export-btn'), document.getElementById('import-btn')
            ];

            controlsToToggle.forEach(control => {
                if (control) {
                    control.disabled = !enable;
                }
            });

            // O match-fieldset é para a interface de registro de partida
            document.getElementById('match-fieldset').disabled = !enable;

            // Esconde containers de criação de novo item
            novoDeckContainer.style.display = 'none';
            novaMatchupContainer.style.display = 'none';
            displayDiv.style.display = 'none';
        }

        function getCurrentDecks(format) {
            return allData[format] && allData[format].decks ? allData[format].decks : {};
        }

        function getCurrentMatchups(format) {
            return allData[format] && allData[format].matchups ? allData[format].matchups : {};
        }

        function getCurrentMatches() {
            return currentFormat && currentDeck && allData[currentFormat] && 
                   allData[currentFormat].decks && allData[currentFormat].decks[currentDeck] 
                   ? allData[currentFormat].decks[currentDeck] : {};
        }

        // ===============================================
        // FUNÇÕES DE CARREGAMENTO E ATUALIZAÇÃO DA UI
        // ===============================================

        // 1. Carrega a lista de usuários
        function popularUserSelector() {
            db.ref('users').once('value')
                .then(snapshot => {
                    // ALTERADO: A opção de reset já está no HTML com value=""
                    userSelect.innerHTML = '<option value="">Selecione seu Nome</option>';
                    if (snapshot.exists()) {
                        const users = snapshot.val();
                        Object.keys(users).forEach(user => {
                            const option = document.createElement('option');
                            option.value = user;
                            option.textContent = user;
                            userSelect.appendChild(option);
                        });
                    }
                    
                    if (currentUser && userSelect.querySelector(`option[value="${currentUser}"]`)) {
                        userSelect.value = currentUser;
                        loadUserData(currentUser);
                    } else {
                        // Se o usuário não existe ou foi resetado
                        currentUser = null;
                        statusElement.textContent = 'Selecione ou crie um usuário.';
                        statusElement.className = 'info';
                        novoUsuarioContainer.style.display = 'block';
                        toggleControls(false);
                    }
                })
                .catch(error => {
                    statusElement.textContent = `Erro ao carregar usuários: ${error.message}`;
                    statusElement.className = 'error';
                    toggleControls(false);
                });
        }

        // 2. Seta o usuário, salva no localStorage e carrega os dados
        function onUserChange(user) {
            if (!user) { // NOVO: Lógica de RESET
                currentUser = null;
                currentFormat = null;
                currentDeck = null;
                localStorage.removeItem('currentUser');
                localStorage.removeItem('currentFormat');
                localStorage.removeItem('currentDeck');
                
                // Limpa a referência do DB e dados locais
                if (dbRef) dbRef.off();
                dbRef = null;
                allData = {};
                
                // Reinicia a UI para o estado inicial
                currentFormatSelect.innerHTML = '<option value="" disabled selected>Selecione o Formato</option>';
                currentDeckSelect.innerHTML = '<option value="">Selecione o Deck</option>'; // Placeholder resetado
                currentDeckSelect.innerHTML += `<option value="${NOVO_DECK_OPCAO}">Criar Novo Deck...</option>`; // Opção de criação
                document.getElementById('current-deck-name').textContent = '';
                novoUsuarioContainer.style.display = 'block';
                
                statusElement.textContent = 'Selecione ou crie um usuário.';
                statusElement.className = 'info';
                toggleControls(false);
                return;
            }
            
            // Lógica original para usuário válido
            currentUser = user;
            localStorage.setItem('currentUser', user);
            currentFormat = null;
            localStorage.removeItem('currentFormat');
            currentDeck = null;
            localStorage.removeItem('currentDeck');
            novoUsuarioContainer.style.display = 'none';
            
            // Re-define a referência do banco de dados para o usuário
            dbRef = db.ref(`users/${currentUser}`);
            loadUserData(user);
        }

        function setNovoUsuario() {
            const nomeUsuario = novoUsuarioInput.value.trim();
            if (!nomeUsuario) {
                statusElement.textContent = 'Por favor, insira um nome de usuário.';
                statusElement.className = 'error';
                return;
            }
            
            // Verifica se já existe, se não, apenas 'loga'
            db.ref(`users/${nomeUsuario}`).once('value')
                .then(snapshot => {
                    if (!snapshot.exists()) {
                        // Cria o nó de usuário (vazio) para que ele apareça no seletor
                        return db.ref(`users/${nomeUsuario}`).set({}).then(() => nomeUsuario);
                    }
                    return nomeUsuario;
                })
                .then(user => {
                    popularUserSelector();
                    userSelect.value = user;
                    onUserChange(user);
                    statusElement.textContent = `Logado como "${user}". Selecione um formato.`;
                    statusElement.className = 'success';
                })
                .catch(error => {
                    statusElement.textContent = `Erro ao criar/logar usuário: ${error.message}`;
                    statusElement.className = 'error';
                });
        }
        
        // 3. Carrega todos os dados do usuário e configura o listener
        function loadUserData(user) {
            if (!user) return;
            
            statusElement.textContent = 'Carregando dados...';
            statusElement.className = 'loading';
            
            // Remove o listener anterior, se houver
            if (dbRef) {
                dbRef.off();
            }

            // Seta a nova referência e configura o listener principal
            dbRef = db.ref(`users/${user}`);

            dbRef.on('value', (snapshot) => {
                allData = snapshot.val() || {};
                
                // Atualiza a UI baseada nos dados
                popularFormatSelector();
                
                statusElement.textContent = 'Dados do usuário carregados.';
                statusElement.className = 'info';
                
                // Força a ativação/desativação da UI
                toggleControls(true);
            }, (error) => {
                statusElement.textContent = `Erro no listener do Firebase: ${error.message}`;
                statusElement.className = 'error';
                toggleControls(false);
            });
        }

        // 4. Popula o seletor de formato e tenta selecionar o formato anterior
        function popularFormatSelector() {
            currentFormatSelect.innerHTML = '<option value="" disabled selected>Selecione o Formato</option>';
            const formats = Object.keys(allData).filter(key => key !== 'matchups' && key !== 'decks'); // Lista de formatos
            
            formats.forEach(format => {
                const option = document.createElement('option');
                option.value = format;
                option.textContent = format;
                currentFormatSelect.appendChild(option);
            });
            
            if (currentFormat && formats.includes(currentFormat)) {
                currentFormatSelect.value = currentFormat;
                onFormatChange(currentFormat);
            } else {
                currentFormat = null;
                currentDeck = null;
                localStorage.removeItem('currentFormat');
                localStorage.removeItem('currentDeck');
                // ALTERADO: Chamado com value="" para a opção de reset
                currentDeckSelect.innerHTML = '<option value="">Selecione o Deck</option>';
                currentDeckSelect.innerHTML += `<option value="${NOVO_DECK_OPCAO}">Criar Novo Deck...</option>`;
                document.getElementById('current-deck-name').textContent = '';
                toggleControls(false); // Desativa tudo, exceto o seletor de formato
                currentFormatSelect.disabled = false;
            }
        }

        // 5. Chamado quando o formato muda
        function onFormatChange(formatName) {
            currentFormat = formatName;
            localStorage.setItem('currentFormat', formatName);
            currentDeck = null;
            localStorage.removeItem('currentDeck');
            popularDeckSelector();
            updateStatsDisplay(null);
            document.getElementById('current-deck-name').textContent = '';

            // Reativa os controles de deck
            currentDeckSelect.disabled = false;
            deckOponenteSelect.disabled = true;
            matchupSelect.disabled = true;
        }

        // 6. Popula o seletor de decks do formato atual
        function popularDeckSelector() {
            // ALTERADO: A opção de reset agora é o placeholder (value="")
            currentDeckSelect.innerHTML = '<option value="">Selecione o Deck</option>';
            // NOVO: "Criar Novo Deck" é sempre a segunda opção (como pedido)
            currentDeckSelect.innerHTML += `<option value="${NOVO_DECK_OPCAO}">Criar Novo Deck...</option>`;
            
            const decks = getCurrentDecks(currentFormat);
            Object.keys(decks).forEach(deckName => {
                const option = document.createElement('option');
                option.value = deckName;
                option.textContent = deckName;
                currentDeckSelect.appendChild(option);
            });

            if (currentDeck && currentDeckSelect.querySelector(`option[value="${currentDeck}"]`)) {
                currentDeckSelect.value = currentDeck;
                onDeckChange(currentDeck);
            } else {
                currentDeck = null;
                localStorage.removeItem('currentDeck');
                // Força o valor para a opção de reset se não houver deck selecionado
                currentDeckSelect.value = ""; 
                onDeckChange("");
            }
        }

        // 7. Chamado quando o deck muda
        function onDeckChange(deckName) {
            if (!deckName) { // NOVO: Lógica de RESET (selecionou "Selecione o Deck")
                currentDeck = null;
                localStorage.removeItem('currentDeck');
                novoDeckContainer.style.display = 'none';
                novoDeckInput.removeAttribute('required');
                novoDeckInput.value = '';
                
                document.getElementById('current-deck-name').textContent = '';
                displayDiv.style.display = 'none';

                // Desativa a interface de registro de partida e matchups
                deckOponenteSelect.disabled = true;
                document.getElementById('play-draw-select').disabled = true; 
                document.getElementById('g1-result').disabled = true;
                document.getElementById('g2-result').disabled = true;
                document.getElementById('g3-result').disabled = true;
                document.getElementById('submit-match').disabled = true;
                matchupSelect.disabled = true;
                novaMatchupContainer.style.display = 'none';
                
                updateStatsDisplay(null);
                return;
            }
            
            if (deckName === NOVO_DECK_OPCAO) {
                currentDeck = null;
                novoDeckContainer.style.display = 'block';
                novoDeckInput.setAttribute('required', 'required');
                novoDeckInput.focus();
                
                // Desativa a interface de registro de partida
                deckOponenteSelect.disabled = true;
                document.getElementById('play-draw-select').disabled = true;
                document.getElementById('g1-result').disabled = true;
                document.getElementById('g2-result').disabled = true;
                document.getElementById('g3-result').disabled = true;
                document.getElementById('submit-match').disabled = true;
                matchupSelect.disabled = true;
                document.getElementById('current-deck-name').textContent = '';
                displayDiv.style.display = 'none';
            } else if (deckName) {
                currentDeck = deckName;
                localStorage.setItem('currentDeck', deckName);
                novoDeckContainer.style.display = 'none';
                novoDeckInput.removeAttribute('required');
                novoDeckInput.value = '';
                document.getElementById('current-deck-name').textContent = deckName;
                
                // Reativa a interface de registro de partida
                deckOponenteSelect.disabled = false;
                document.getElementById('play-draw-select').disabled = false; 
                document.getElementById('g1-result').disabled = false;
                document.getElementById('g2-result').disabled = false;
                document.getElementById('g3-result').disabled = false;
                document.getElementById('submit-match').disabled = false;
                
                // Popula os seletores de matchup
                popularMatchupSelectors();
                
                // Atualiza as estatísticas gerais
                updateStatsDisplay(null);
            }
        }

        // 8. Cria um novo deck no Firebase
        function criarNovoDeck() {
            const nomeDeck = novoDeckInput.value.trim();
            if (!nomeDeck || !dbRef || !currentFormat) {
                statusElement.textContent = 'Erro: Selecione um usuário e formato primeiro.';
                statusElement.className = 'error';
                return;
            }
            // Checagem duplicada localmente
            if (getCurrentDecks(currentFormat)[nomeDeck]) {
                statusElement.textContent = 'Esse deck já existe nesse formato!';
                statusElement.className = 'error';
                return;
            }
            
            // Cria o deck no Firebase imediatamente (vazio)
            const deckRef = dbRef.child(currentFormat).child('decks').child(nomeDeck);
            deckRef.set({})
                .then(() => {
                    currentDeck = nomeDeck;
                    novoDeckContainer.style.display = 'none';
                    novoDeckInput.value = '';
                    
                    // CORREÇÃO DO FURO LÓGICO: Força a repopulação e seleção imediata
                    popularDeckSelector(); 
                    currentDeckSelect.value = nomeDeck; 
                    onDeckChange(nomeDeck);
                    
                    // O listener do Firebase irá atualizar allData automaticamente
                    statusElement.textContent = `Deck "${nomeDeck}" criado com sucesso no formato ${currentFormat}!`;
                    statusElement.className = 'success';
                })
                .catch(error => {
                    statusElement.textContent = `Erro ao criar deck: ${error.message}`;
                    statusElement.className = 'error';
                });
        }
        
        // 9. Popula os seletores de matchup (oponente e estatísticas)
        function popularMatchupSelectors() {
            const matchups = getCurrentMatchups(currentFormat);
            const matchupNames = Object.keys(matchups);
            
            // Seletor de Oponente (Formulário)
            // ALTERADO: Placeholder é value="" e já está no HTML
            deckOponenteSelect.innerHTML = '<option value="">Selecione o Deck</option>';
            deckOponenteSelect.innerHTML += `<option value="${NOVA_MATCHUP_OPCAO}">Adicionar Nova Matchup...</option>`;
            
            // Seletor de Estatísticas
            // ALTERADO: Placeholder é value="" e já está no HTML
            matchupSelect.innerHTML = '<option value="">Selecione uma Matchup</option>';
            matchupSelect.disabled = matchupNames.length === 0;

            matchupNames.forEach(name => {
                const optionOpponent = document.createElement('option');
                optionOpponent.value = name;
                optionOpponent.textContent = name;
                deckOponenteSelect.appendChild(optionOpponent);
                
                const optionStats = document.createElement('option');
                optionStats.value = name;
                optionStats.textContent = name;
                matchupSelect.appendChild(optionStats);
            });
        }
        
        // ===============================================
        // FUNÇÕES DE CÁLCULO DE ESTATÍSTICAS
        // ===============================================

        function calculateStats(filteredData) {
            // Note: O Firebase armazena partidas como um objeto de objetos. Convertemos para array aqui.
            const matchesArray = Object.values(filteredData || {});
            
            let totalMatches = 0, matchesWon = 0, totalGames = 0, gamesWon = 0;
            let g1Total = 0, g1Won = 0, g2Total = 0, g2Won = 0, g3Total = 0, g3Won = 0;
            
            // Rastreamento Play/Draw
            let playTotalMatches = 0, playWonMatches = 0;
            let drawTotalMatches = 0, drawWonMatches = 0;
            // FIM NOVO

            for (const match of matchesArray) {
                // Não há mais filtro de formato, pois getCurrentMatches() já filtra
                
                const g1 = match.g1Result ? match.g1Result.toLowerCase() : '';
                const g2 = match.g2Result ? match.g2Result.toLowerCase() : '';
                const g3 = match.g3Result ? match.g3Result.toLowerCase() : 'not_played';

                if (g1) { g1Total++; if (g1 === 'win') { g1Won++; gamesWon++; } }
                if (g2) { g2Total++; if (g2 === 'win') { g2Won++; gamesWon++; } }
                if (g3 !== 'not_played' && g3) { g3Total++; if (g3 === 'win') { g3Won++; gamesWon++; } }

                totalMatches++;
                let wins = (g1 === 'win' ? 1 : 0) + (g2 === 'win' ? 1 : 0) + (g3 === 'win' ? 1 : 0);
                let matchWon = wins >= 2;
                if (matchWon) matchesWon++;
                
                // Rastreamento Play/Draw
                const playDraw = match.playDraw ? match.playDraw.toLowerCase() : null;
                if (playDraw === 'play') {
                    playTotalMatches++;
                    if (matchWon) playWonMatches++;
                } else if (playDraw === 'draw') {
                    drawTotalMatches++;
                    if (matchWon) drawWonMatches++;
                }
                // FIM NOVO
            }

            totalGames = g1Total + g2Total + g3Total;

            const formatWR = (num, den) => den > 0 ? (num / den * 100).toFixed(1) + '%' : '--%';
            
            return {
                totalMatches: totalMatches, // Retorna o total para atualizar o status
                generalWinRate: formatWR(matchesWon, totalMatches),
                gameWinRate: formatWR(gamesWon, totalGames),
                g1WinRate: formatWR(g1Won, g1Total),
                g2WinRate: formatWR(g2Won, g2Total),
                g3WinRate: formatWR(g3Won, g3Total),
                // Retornos Play/Draw
                playWinRate: formatWR(playWonMatches, playTotalMatches),
                drawWinRate: formatWR(drawWonMatches, drawTotalMatches),
                // FIM NOVO
            };
        }

        // 10. Atualiza a exibição de estatísticas (geral ou por matchup)
        function updateStatsDisplay(matchupName = null) {
            const currentMatches = getCurrentMatches();
            let filteredMatches;

            if (matchupName) {
                // Filtra as partidas pelo nome do oponente
                filteredMatches = Object.values(currentMatches).filter(m => m.deckOponente === matchupName);
                document.getElementById('matchup-name').textContent = matchupName;
                displayDiv.style.display = 'block';
            } else {
                // Estatísticas gerais do deck
                filteredMatches = currentMatches;
                displayDiv.style.display = 'none';
            }

            const stats = calculateStats(filteredMatches);

            if (matchupName) {
                // Estatísticas por Matchup
                document.getElementById('matchup-wr-match').textContent = stats.generalWinRate;
                document.getElementById('matchup-wr-game').textContent = stats.gameWinRate;
                document.getElementById('matchup-wr-g1').textContent = stats.g1WinRate;
                document.getElementById('matchup-wr-g2').textContent = stats.g2WinRate;
                document.getElementById('matchup-wr-g3').textContent = stats.g3WinRate;
                // Atualiza Play/Draw Matchup
                document.getElementById('matchup-wr-play').textContent = stats.playWinRate;
                document.getElementById('matchup-wr-draw').textContent = stats.drawWinRate;
            } else {
                // Estatísticas Gerais
                document.getElementById('wr-match-geral').textContent = stats.generalWinRate;
                document.getElementById('wr-game-geral').textContent = stats.gameWinRate;
                document.getElementById('wr-g1-geral').textContent = stats.g1WinRate;
                document.getElementById('wr-g2-geral').textContent = stats.g2WinRate;
                document.getElementById('wr-g3-geral').textContent = stats.g3WinRate;
                // Atualiza Play/Draw Geral
                document.getElementById('wr-play-geral').textContent = stats.playWinRate;
                document.getElementById('wr-draw-geral').textContent = stats.drawWinRate;

                const matchCount = stats.totalMatches;
                if (matchCount > 0) {
                    statusElement.textContent = `Deck pronto. Total de Partidas: ${matchCount}`;
                    statusElement.className = 'info';
                } else {
                    statusElement.textContent = 'Nenhuma partida registrada para este deck.';
                    statusElement.className = 'warning';
                }
            }
        }
        
        // ===============================================
        // FUNÇÕES DE DADOS E EVENTOS
        // ===============================================

        // 11. Adiciona a partida ao Firebase
        function addMatch(matchData) {
            if (!currentDeck || !currentFormat) {
                statusElement.textContent = 'Erro: Selecione um deck e formato antes de registrar.';
                statusElement.className = 'error';
                return;
            }

            const matchRef = dbRef.child(currentFormat).child('decks').child(currentDeck).push();
            matchRef.set(matchData)
                .then(() => {
                    statusElement.textContent = 'Partida registrada com sucesso!';
                    statusElement.className = 'success';
                    
                    // Adicionar o oponente à lista de Matchups se for novo
                    const oponente = matchData.deckOponente;
                    const matchupRef = dbRef.child(currentFormat).child('matchups').child(oponente);
                    matchupRef.once('value')
                        .then(snapshot => {
                            if (!snapshot.exists()) {
                                // Cria o nó vazio para que o listener principal o capture
                                return matchupRef.set(true); 
                            }
                        })
                        .catch(err => console.error("Erro ao verificar/criar matchup:", err));

                    // Não é preciso chamar updateStatsDisplay, o listener do Firebase fará isso.
                })
                .catch(error => {
                    statusElement.textContent = `Erro ao registrar partida: ${error.message}`;
                    statusElement.className = 'error';
                });
        }
        
        // 12. Funções de Exportação e Importação (JSON)
        
        document.getElementById('export-btn').addEventListener('click', () => {
            if (!currentUser) return;
            const dataToExport = {
                user: currentUser,
                data: allData
            };
            const jsonString = JSON.stringify(dataToExport, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `deck_tracker_export_${currentUser}_${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            statusElement.textContent = 'Dados exportados com sucesso.';
            statusElement.className = 'success';
        });

        document.getElementById('import-btn').addEventListener('click', () => {
            fileInput.click();
        });

        function handleFileSelect(evt) {
            if (!currentUser) {
                statusElement.textContent = 'Erro: Selecione um usuário antes de importar.';
                statusElement.className = 'error';
                return;
            }

            const file = evt.target.files[0];
            if (!file) {
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (!importedData.data) {
                        throw new Error("Formato de arquivo inválido. 'data' não encontrado.");
                    }

                    // A importação sobrescreve os dados do usuário atual
                    dbRef.set(importedData.data)
                        .then(() => {
                            statusElement.textContent = `Dados de ${importedData.user || 'arquivo'} importados para o usuário ${currentUser} com sucesso!`;
                            statusElement.className = 'success';
                            // O listener irá atualizar a UI
                        })
                        .catch(error => {
                            statusElement.textContent = `Erro ao salvar dados importados: ${error.message}`;
                            statusElement.className = 'error';
                        });
                } catch (error) {
                    statusElement.textContent = `Erro ao ler ou processar arquivo: ${error.message}`;
                    statusElement.className = 'error';
                }
            };
            reader.readAsText(file);
        }

        // ===============================================
        // LISTENERS DE EVENTOS
        // ===============================================
        
        userSelect.addEventListener('change', (e) => onUserChange(e.target.value));
        
        currentFormatSelect.addEventListener('change', (e) => onFormatChange(e.target.value));
        
        currentDeckSelect.addEventListener('change', (e) => onDeckChange(e.target.value));

        matchForm.addEventListener('submit', (e) => {
            e.preventDefault();
            
            const deckOponente = deckOponenteSelect.value === NOVA_MATCHUP_OPCAO 
                               ? novaMatchupInput.value.trim() 
                               : deckOponenteSelect.value;
            const g1Result = document.getElementById('g1-result').value;
            const g2Result = document.getElementById('g2-result').value;
            const g3Result = document.getElementById('g3-result').value;
            const playDraw = document.getElementById('play-draw-select').value; 

            // A validação agora trata value="" como campo obrigatório não preenchido
            if (!deckOponente || !g1Result || !g2Result || !playDraw) { 
                statusElement.textContent = 'Preencha todos os campos obrigatórios!';
                statusElement.className = 'error';
                return;
            }
            
            const newMatch = {
                timestamp: new Date().toISOString(),
                deckProprio: currentDeck,
                deckOponente: deckOponente,
                playDraw: playDraw,
                g1Result: g1Result,
                g2Result: g2Result,
                g3Result: g3Result
            };
                        
            addMatch(newMatch);
            
            // Limpa o formulário e reseta para a opção de reset
            matchForm.reset();
            document.getElementById('g3-result').value = 'not_played';
            document.getElementById('play-draw-select').value = ''; 
            deckOponenteSelect.value = ''; // Reset do oponente para a opção Selecione o Deck
            novaMatchupContainer.style.display = 'none';
        });

        matchupSelect.addEventListener('change', (e) => {
            const selectedMatchup = e.target.value;
            if (selectedMatchup) {
                updateStatsDisplay(selectedMatchup);
            } else {
                // Se selecionar a opção de reset (value=""), reseta o display
                displayDiv.style.display = 'none';
                updateStatsDisplay(null);
            }
        });

        deckOponenteSelect.addEventListener('change', (e) => {
            if (e.target.value === NOVA_MATCHUP_OPCAO) {
                novaMatchupContainer.style.display = 'block';
                novaMatchupInput.setAttribute('required', 'required');
                novaMatchupInput.focus();
            } else {
                novaMatchupContainer.style.display = 'none';
                novaMatchupInput.removeAttribute('required');
                novaMatchupInput.value = '';
            }
        });

        fileInput.addEventListener('change', handleFileSelect, false);

        // Initialization
        document.addEventListener('DOMContentLoaded', () => {
            popularUserSelector(); // Popula o dropdown de usuários primeiro e inicia o carregamento dos dados
        });
    </script>
</body>
</html>
